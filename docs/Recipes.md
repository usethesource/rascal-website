## Document preparation issues

The following issues have been detected while preparing this draft document. It is not ready for publication.

1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/Visualization.md|:21,0 Ambiguous concept link: Recipes:Visualization-PlayingWithProperties resolves to all of {"/Recipes.md#Visualization-PlayingWithProperties","#Visualization-PlayingWithProperties"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/Visualization.md|:21,0 Ambiguous concept link: Recipes:Visualization-ADT resolves to all of {"#Visualization-ADT","/Recipes.md#Visualization-ADT"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/Visualization.md|:21,0 Ambiguous concept link: Recipes:Visualization-MyFirstBox resolves to all of {"/Recipes.md#Visualization-MyFirstBox","#Visualization-MyFirstBox"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/Visualization.md|:21,0 Ambiguous concept link: Recipes:Visualization-InteractiveBoxHeight resolves to all of {"/Recipes.md#Visualization-InteractiveBoxHeight","#Visualization-InteractiveBoxHeight"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/Visualization.md|:21,0 Ambiguous concept link: Recipes:Visualization-DrawLogo resolves to all of {"/Recipes.md#Visualization-DrawLogo","#Visualization-DrawLogo"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/Visualization.md|:21,0 Ambiguous concept link: Recipes:Visualization-ParseTree resolves to all of {"#Visualization-ParseTree","/Recipes.md#Visualization-ParseTree"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/PlayingWithProperties/PlayingWithProperties.md|:27,0 Broken concept link: Libraries:Properties-lineStyle
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/PlayingWithProperties/PlayingWithProperties.md|:36,0 Broken concept link: Libraries:Properties-lineWidth
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/PlayingWithProperties/PlayingWithProperties.md|:45,0 Broken concept link: Libraries:Properties-lineColor
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/PlayingWithProperties/PlayingWithProperties.md|:54,0 Broken concept link: Libraries:Properties-fillColor
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/PlayingWithProperties/PlayingWithProperties.md|:63,0 Broken concept link: Libraries:Properties-shadow
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/PlayingWithProperties/PlayingWithProperties.md|:72,0 Broken concept link: Libraries:Properties-shadowColor
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/ADT/ADT.md|:35,0 Broken concept link: Libraries:Properties-gap
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/ADT/ADT.md|:35,0 Broken concept link: Libraries:Properties-size
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/ADT/ADT.md|:35,0 Broken concept link: Libraries:std
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/ADT/ADT.md|:53,0 Broken concept link: Libraries:Properties-manhattan
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/ADT/ADT.md|:64,0 Broken concept link: Libraries:Properties-orientation
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/MyFirstBox/MyFirstBox.md|:18,0 Broken concept link: Libraries:Figure-box
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/MyFirstBox/MyFirstBox.md|:35,0 Broken concept link: Libraries:Properties-size
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/MyFirstBox/MyFirstBox.md|:52,0 Broken concept link: Libraries:Properties-shrink
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/MyFirstBox/MyFirstBox.md|:66,0 Broken concept link: Libraries:Properties-hshrink
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Visualization/MyFirstBox/MyFirstBox.md|:67,0 Broken concept link: Libraries:Properties-vshrink
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringJava.md|:50,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringJava.md|:54,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:30,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:34,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:38,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:42,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:46,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:50,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:59,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:63,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringClasses/MeasuringClasses.md|:68,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:21,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:21,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:27,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:31,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:35,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:40,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:44,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:48,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:52,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:56,0 Code execution failed
1. [error] |project://rascal/src/org/rascalmpl/courses/Recipes/Metrics/MeasuringJava/MeasuringMethods/MeasuringMethods.md|:60,0 Code execution failed
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-Quine resolves to all of {"/Recipes.md#Basic-Quine","#Basic-Quine"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-Even resolves to all of {"/Recipes.md#Basic-Even","#Basic-Even"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-Factorial resolves to all of {"#Basic-Factorial","/Recipes.md#Basic-Factorial"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-Bubble resolves to all of {"#Basic-Bubble","/Recipes.md#Basic-Bubble"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-Hello resolves to all of {"#Basic-Hello","/Recipes.md#Basic-Hello"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-Squares resolves to all of {"/Recipes.md#Basic-Squares","#Basic-Squares"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-FizzBuzz resolves to all of {"/Recipes.md#Basic-FizzBuzz","#Basic-FizzBuzz"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Basic.md|:17,0 Ambiguous concept link: Recipes:Basic-BottlesOfBeer resolves to all of {"/Recipes.md#Basic-BottlesOfBeer","#Basic-BottlesOfBeer"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Factorial/Factorial.md|:25,0 Broken concept link: Rascal:Concepts-Function
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Bubble/Bubble.md|:17,0 Broken concept link: Libraries:List-sort
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Hello/Hello.md|:21,0 Broken concept link: Libraries:Prelude-IO
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Squares/Squares.md|:22,0 Broken concept link: Libraries:Prelude-IO
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/Squares/Squares.md|:43,0 Broken concept link: Libraries:Prelude-IO
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Basic/BottlesOfBeer/BottlesOfBeer.md|:29,0 Ambiguous concept link: Rascal:Declarations-Function resolves to all of {"#Declarations-Function","/Rascal.md#Declarations-Function"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Languages.md|:17,0 Ambiguous concept link: Recipes:Languages-Pico resolves to all of {"/Recipes.md#Languages-Pico","#Languages-Pico"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Languages.md|:17,0 Ambiguous concept link: Recipes:Languages-Lisra resolves to all of {"#Languages-Lisra","/Recipes.md#Languages-Lisra"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Languages.md|:17,0 Ambiguous concept link: Recipes:Languages-Exp resolves to all of {"#Languages-Exp","/Recipes.md#Languages-Exp"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Languages.md|:17,0 Ambiguous concept link: Recipes:Languages-Func resolves to all of {"/Recipes.md#Languages-Func","#Languages-Func"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Pico/IDE/IDE.md|:52,0 Ambiguous concept link: Screenshot3.png resolves to all of {"/assets/e9bf3fa4-d88e-4a39-94e6-950b1612f5a7.png","/assets/64009781-8163-4d7a-b8d7-9d9d8f78e798.png"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Pico/Load/Load.md|:29,0 Broken concept link: Libraries:Prelude-RunTimeException
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Lisra/Parse/Parse.md|:33,0 Broken concept link: Concrete Patterns
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Exp/Abstract/Abstract.md|:43,0 Ambiguous concept link: Rascal:Declarations-Function resolves to all of {"#Declarations-Function","/Rascal.md#Declarations-Function"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Exp/Concrete/WithLayout/WithLayout.md|:37,0 Broken concept link: Rascal:Concepts-PatternMatching
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Exp/Combined/Automatic/Automatic.md|:16,0 Broken concept link: Libraries:ParseTree-implode
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Func/LoadAST/LoadAST.md|:21,0 Broken concept link: Libraries:PareTree-implode
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Func/Parse/Parse.md|:16,0 Broken concept link: Libraries:ParseTree-parse
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Languages/Func/Parse/Parse.md|:17,0 Broken concept link: Libraries:Prelude-ParseTree
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-Derivative resolves to all of {"#Common-Derivative","/Recipes.md#Common-Derivative"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-CallAnalysis resolves to all of {"/Recipes.md#Common-CallAnalysis","#Common-CallAnalysis"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-WordCount resolves to all of {"#Common-WordCount","/Recipes.md#Common-WordCount"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-WordReplacement resolves to all of {"#Common-WordReplacement","/Recipes.md#Common-WordReplacement"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-CallLifting resolves to all of {"/Recipes.md#Common-CallLifting","#Common-CallLifting"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-ColoredTrees resolves to all of {"/Recipes.md#Common-ColoredTrees","#Common-ColoredTrees"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-StringTemplate resolves to all of {"#Common-StringTemplate","/Recipes.md#Common-StringTemplate"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-AdHocDataExploration resolves to all of {"/Recipes.md#Common-AdHocDataExploration","#Common-AdHocDataExploration"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/Common.md|:17,0 Ambiguous concept link: Recipes:Common-CountConstructors resolves to all of {"#Common-CountConstructors","/Recipes.md#Common-CountConstructors"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/CallAnalysis/CallAnalysis.md|:35,0 Ambiguous concept link: CallAnalysis-calls.png resolves to all of {"/assets/13864239-a7ce-4958-83e2-9e4f37f2bde8.png","/assets/ac48f8f2-2105-4c68-91fa-c1409e941c20.png"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/WordCount/WordCount.md|:64,0 Ambiguous concept link: Rascal:Expressions-Reducer resolves to all of {"/Rascal.md#Expressions-Reducer","#Expressions-Reducer"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/WordCount/CountInLine3/CountInLine3.md|:24,0 Ambiguous concept link: Rascal:Expressions-Reducer resolves to all of {"/Rascal.md#Expressions-Reducer","#Expressions-Reducer"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/WordReplacement/WordReplacement.md|:25,0 Ambiguous concept link: Rascal:Patterns-Regular resolves to all of {"/Rascal.md#Patterns-Regular","#Patterns-Regular"}
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/CountConstructors/CountConstructors.md|:18,0 Broken concept link: Rascal:Concepts-StaticTyping
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/CountConstructors/CountConstructors.md|:19,0 Broken concept link: Rascal:Declrations-AlgebraicDataType
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/CountConstructors/CountConstructors.md|:39,0 Broken concept link: Libraries:Node-getName
1. [warning] |project://rascal/src/org/rascalmpl/courses/Recipes/Common/CountConstructors/CountConstructors.md|:44,0 Broken concept link: Libraries:Map-domainR

## Recipes {#Recipes}

### Synopsis 
Recipes for writing Rascal programs.





### Description 
These _Rascal Recipes_ are a work-in-progress but will gradually evolve into a collection of basic Rascal language examples and use cases.
It consists of the following parts:

* [Recipes:Visualization](/Recipes.md#Visualization-Visualization)
* [Recipes:Metrics](/Recipes.md#Metrics-Metrics)
* [Recipes:Basic](/Recipes.md#Basic-Basic)
* [Recipes:Languages](/Recipes.md#Languages-Languages)
* [Recipes:Common](/Recipes.md#Common-Common)

The following features are covered:

*  Basic language features.
*  Common tasks.
*  Fact extraction.
*  Language definition.
*  Syntax definition.
*  Parsing.
*  Transformation.
*  Code generation.
*  IDE extensions.
*  Visualization.






## Visualization {#Visualization-Visualization}

### Synopsis 
Recipes for creating visualizations.





### Description 

WARNING: The visualization library is being reimplemented and reorganized; 
the information provided here maybe inaccurate or even incorrect

We cover the following topics:

* _broken:Recipes:Visualization-PlayingWithProperties (ambiguous link)_
* _broken:Recipes:Visualization-ADT (ambiguous link)_
* _broken:Recipes:Visualization-MyFirstBox (ambiguous link)_
* _broken:Recipes:Visualization-InteractiveBoxHeight (ambiguous link)_
* _broken:Recipes:Visualization-DrawLogo (ambiguous link)_
* _broken:Recipes:Visualization-ParseTree (ambiguous link)_





## Playing With Properties {#Visualization-PlayingWithProperties}

### Synopsis 
Illustrate the effect of various figure properties.






### Examples 
Here is an ellipse with minimum size 200x300 that occupies 80% of the available space:
```rascal-figure,width=,height=,file=e1.png
                e = ellipse(size(200,100), shrink(0.8));
render(e);
```

![](/assets/1a14efd9-eafb-47a8-a758-cfdaa6a8b004.png)

(we add the shrink to leave some space for thick lines and shadows below).

Change the style of its border using [lineStyle]_Libraries:Properties-lineStyle (broken link)_:
```rascal-figure,width=,height=,file=e2.png
                e = ellipse(size(200,100), shrink(0.8), lineStyle("dot"));
render(e);
```

![](/assets/ff81414d-4869-46be-b3b6-90bd0d0cb772.png)


Change the thickness of its border using [lineWidth]_Libraries:Properties-lineWidth (broken link)_:
```rascal-figure,width=,height=,file=e3.png
                e = ellipse(size(200,100), shrink(0.8), lineWidth(5));
render(e);
```

![](/assets/0fca5305-6d4d-439a-9b18-b52456ff15a0.png)


Change the color of its border using [lineColor]_Libraries:Properties-lineColor (broken link)_:
```rascal-figure,width=,height=,file=e4.png
                e = ellipse(size(200,100), shrink(0.8), lineColor("blue"));
render(e);
```

![](/assets/fac61382-4191-4020-8830-1277e0fed407.png)


Change the color of its area using [fillColor]_Libraries:Properties-fillColor (broken link)_:
```rascal-figure,width=,height=,file=e5.png
                e = ellipse(size(200,100), shrink(0.8), fillColor("yellow"));
render(e);
```

![](/assets/944ace67-c1a7-49db-8154-a36be123a49b.png)


Add a shadow using [shadow]_Libraries:Properties-shadow (broken link)_:
```rascal-figure,width=,height=,file=e6.png
                e = ellipse(size(200,100), shrink(0.8), shadow(true));
render(e);
```

![](/assets/85ba66da-c697-470b-aae7-f91e9d42b03a.png)


Add the color of the shadow using [shadowColor]_Libraries:Properties-shadowColor (broken link)_:
```rascal-figure,width=,height=,file=e7.png
                e = ellipse(size(200,100), shrink(0.8), shadow(true), shadowColor("grey"));
render(e);
```

![](/assets/2746a4ca-6a05-4067-bdac-9ab9b4813c08.png)


Finally, enjoy the grande finale:
```rascal-figure,width=,height=,file=e8.png
                e = ellipse(size(200,100), shrink(0.8), lineStyle("dot"), lineWidth(5), lineColor("blue"), fillColor("yellow"), shadow(true), shadowColor("grey"));
render(e);
```

![](/assets/288b036a-0e9d-4547-a61e-b656f3a853ed.png)







## ADT {#Visualization-ADT}

### Synopsis 
Visualize an Algebraic Datatype as a tree.





### Description 
In [Colored trees](#Common-ColoredTrees) we have discussed the Algebraic Data Type `ColoredTree`.
Here we show how to create a visualization for them. The global approach is:

*  Define a function `visColoredTree` that has a ColoredTree as argument and 
  creates a `Figure` for it.
*  Display the resulting figure using [$Rascal:Render/render].

### Examples 
Here is our solution:
```rascal
include::{LibDir}demo/vis/VisADT.rsc[tags=module]
```

<1> A `leaf` is represented as its number converted to text, surrounded by a lightyellow box.
<2> The figure for non-leaf nodes of a ColoredTree is generated by the auxiliary function `visNode`.
<3> `visNode` represents the node itself as a [$Rascal:Figures/tree] that has a colored ellipse as root and the visualization of
    two ColoredTrees as children.


For the example `ColoredTree` `rb` we can set a standard 
(see []_Libraries:std (broken link)_) [size]_Libraries:Properties-size (broken link)_ and standard [gap]_Libraries:Properties-gap (broken link)_:
```rascal-figure,width=,height=,file=a1.png
                import demo::vis::VisADT;
render(space(visColoredTree(rb), std(size(30)), std(gap(30))));
```
and the result is:


![](/assets/61e5bfe8-160e-4ac8-a4ab-cdd4298d680a.png)


Note that:

*  We place the Figure that is produced by `viscoloredTree` in a `space` for the sole purpose that add extra properties to it.
*  We use `std(size(30))` and ` std(gap(30))` to achieve that these properties are set for all subfigures.


Some further custumizations are possible. By default, the tree visualization 
uses [manhattan]_Libraries:Properties-manhattan (broken link)_ style. If we turn it off
```rascal-figure,width=,height=,file=a2.png
                import demo::vis::VisADT;
render(space(visColoredTree(rb), std(size(30)), std(gap(30)), std(manhattan(false))));
```
the result is:


![](/assets/7255eaaf-714b-44f0-a589-0b7136e4f289.png)


It is also possible to change the [orientation]_Libraries:Properties-orientation (broken link)_ of the tree and draw it, for example, from left to right:
```rascal-figure,width=,height=,file=a3.png
                import demo::vis::VisADT;
render(space(visColoredTree(rb), std(size(30)), std(gap(30)), std(orientation(leftRight()))));
```
the result is:


![](/assets/be09c734-b0ec-45cd-ba4c-971cf8a2ab28.png)





## My First Box {#Visualization-MyFirstBox}

### Synopsis 
Drawing a box in many variations.






### Examples 

Drawing a red [box]_Libraries:Figure-box (broken link)_ is as simple as this:
```rascal-figure,width=,height=,file=b1.png
import vis::Figure;
import vis::Render;
b = box(fillColor("red"));
render(b);
```
and it will look like this:

![](/assets/5c790c18-f738-49c8-a44e-a1c92c829f0c.png)
 or rather, it will look like this:



![](/assets/6123d753-a8b8-4be9-97c4-530985fc7b1c.png)


Wow, the box fills the whole window! So lets give our box a [size]_Libraries:Properties-size (broken link)_:
```rascal-figure,width=,height=,file=b2.png
import vis::Figure;
import vis::Render;
b = box(fillColor("red"), size(200,100));
render(b);
```
and it will look like this:

![](/assets/8db979cf-dd6f-4cd9-ac94-2f5baa03393e.png)


On screen however, it still fills the whole window as shown above.
The lesson here is that size is to be taken as *minimum size* (and probably we should
rename `size` to `minSize` to emphasize this).

So how can we produce a box that does _not_ fill the whole window? The answer is to define the size of the box
_relative_ to its surroundings by using [shrink]_Libraries:Properties-shrink (broken link)_:

```rascal-figure,width=,height=,file=b3.png
import vis::Figure;
import vis::Render;
b = box(fillColor("red"), shrink(0.5));
render(b);
```
which says: _I am a red box and I want to occupy 50% of the available space._ The result is:


![](/assets/5deac250-e771-4855-b194-ef7867af7dc2.png)


Shrinking can also be limited to one dimension using [hshrink]_Libraries:Properties-hshrink (broken link)_ 
or [vshrink]_Libraries:Properties-vshrink (broken link)_:
```rascal-figure,width=,height=,file=b4.png
import vis::Figure;
import vis::Render;
b = box(fillColor("red"), hshrink(0.5));
render(b);
```
which says:_ I am a red box and I want to occupy 50% of the available space in the horizontal direction and 100% of the available space in the vertical direction._ The result is:


![](/assets/64009781-8163-4d7a-b8d7-9d9d8f78e798.png)


Relative sizes can also be used when figures are nested.

```rascal-figure,width=,height=,file=b5.png
import vis::Figure;
import vis::Render;
b1 = box(fillColor("red"), hshrink(0.5));
b2 = box(b1, fillColor("yellow"), size(200,100));
render(b2);
```

![](/assets/abb0431e-fcd0-4bd6-bb7c-03bd05782a15.png)     



### Pitfalls 

In the above examples we have consistently added the two imports:
```rascal
import vis::Figure;
import vis::Render;
```
In other recipes and the Rascal documentation we omit these two imports to avoid cluttering our examples with irrelevant details.
Be aware that you will always need them when creating a visualisation.


## Interactive Box Height {#Visualization-InteractiveBoxHeight}

### Synopsis 
Control the height of a box with user input.





### Description 

*  A text entry field to enter numbers.
*  A box, whose height is controlled by the numer entered in the text field.

### Examples 
Here is a solution:
```rascal
include::{LibDir}demo/vis/Higher.rsc[tags=module]
```

                
The auxiliary function `intInput` checks that a strings consists solely of digits.
Function `higher` can be understood as follows:

*  A local variable `H` is used to maintain the current height.
*  It returns a vertical concatenation of two elements: a [Rascal:textfield] and a [Rascal:box].
*  The textfield has three arguments:
**  A string that is the initial value of the text field.
**  A call back function `void(str s){H = toInt(s);}` that is called when text entry is complete:
     argument `s` is the text entered and the effect is to convert that text to a number and assign it to `H`.
**  Function `intInput` that checks that only numbers are entered.
**  The box has
**  a fixed width
**  it is not vertically resizable.
**  It has a vertical size that that depends on an anonymous function `vsize(num(){return H;})` that returns the value of `H`. 
**  Its color is red.


Rendering this figure:
```rascal-figure,width=,height=,file=h1.png
import demo::vis::Higher;
render(higher());
```
gives


![](/assets/8733d233-181e-4d60-91f7-9822dc1196a2.png)


Unfortunately we cannot show the interaction here, so run this example from the `demo` directory and watch how the height of the box changes when you enter a new number in the text field.




## Draw a Logo {#Visualization-DrawLogo}

### Synopsis 
Draw the Rascal logo.





### Description 

Given a 50x50 matrix containing the colors of the Rascal logo,
we can reproduce it as visualization.

### Examples 
Here is the solution:
```rascal
include::{LibDir}demo/vis/Logo.rsc[tags=module]
```

                
We can use it as follows:
```rascal-figure,width=,height=,file=logo1.png
                import demo::vis::Logo;
render(logo());
```
will produce:

![](/assets/1da6f84b-bcfd-4fae-ac1c-37989bd10d34.png)

or as a screenshot:


![](/assets/24bff4b2-4a75-4d57-bc4a-b1e9bfe94a38.png)






## ParseTree {#Visualization-ParseTree}

### Synopsis 
Visualize a parse tree.





### Description 
A parse tree is a (usually large) internal representation of  a parsed text.
In the rare situation that it is necessary to read or inspect a parse tree,
a visualization can be useful.

### Examples 
We embark on visualizing parse trees for the language Exp:

```rascal-shell
rascal>import demo::lang::Exp::Concrete::WithLayout::Syntax;
ok
rascal>import ParseTree;
ok
rascal>parse(#Exp, "1+2*3");
Exp: (Exp) `1+2*3`
```
As can be seen, even for such a trivial example, the details in the parse tree representation become sizeable.

We can visualize it as follows:
```rascal-figure,width=100,height=100,file=t1.png
import demo::lang::Exp::Concrete::WithLayout::Syntax;
import ParseTree;
import vis::Figure;
import vis::ParseTree;
import vis::Render;
render(visParsetree(parse(#Exp, "1+2*3")));
```
With as result:

![](/assets/fe43ee8f-07d7-44af-a29e-879d4e3a8d20.png)


The figure is interactive (not available here):

*  Rectangles with blue text are terminal symbols.
*  Little circles represent non-terminals: hovering over them shows the corresponding grammar rule.
*  Little grey rectangles represent layout: hovering over them also shows the corresponding lexical rule.

### Benefits 

*  A dense, structured, representation of a parse tree that provides extra information via interaction.

### Pitfalls 

*  This visualization does not scale to huge trees.


## Metrics {#Metrics-Metrics}

### Synopsis 
Computing 



### Function 
       







## Measuring Java {#Metrics-MeasuringJava}

### Synopsis 
A few steps using the M3 model to compute basic metrics for a Java project in Eclipse



### Function 
       


### Description 


This is a recipe for computing basic or more advanced metrics from a Java project in Eclipse. We assume:

*  You have Rascal installed in an Eclipse instance.
*  You have a Java project in your Eclipse workspace that compiles without errors. Let's call it `HelloWorld`.


Now we will follow the [EASY](#EASY-EASY) paradigm:

*  a library will be used to _parse_ the Java code generating [Rascalopedia:AbstractSyntaxTree]
*  the same library will generate a [Rascal:Values/Relation]al model to represent interesting facts between Java source code artifacts
*  then we can write queries over the generated trees and relations using [Rascal:Expressions].


These are a number of recipes for measuring different things about Java:

*  [MeasuringClasses]
*  [MeasuringMethods]

### Examples 



```rascal-shell
```
First we import the basic data types for representing Java. The model is called _M3_, and its definition is split acros a generic
language independent module called [Rascal:analysis/m3/Core] and a Java specific part called [Rascal:lang/java/m3/Core]. Have a look at the documentation 
of these modules later. For now we will go through using them in a few examples.

```rascal-shell
rascal>import lang::java::m3::Core;
ok
```
Then we import the API for extracting an M3 model from an Eclipse project. 

```rascal-shell
rascal>import lang::java::jdt::m3::Core;
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(0,33,<1,0>,<1,33>): Could not import module lang::java::jdt::m3::Core: can not find in search path
Advice: |http://tutor.rascal-mpl.org/Errors/Static/ModuleImport/ModuleImport.html|
</pre>
:::

```rascal-shell
ok
```
Calling the following function generates an enormous value representing everything the Eclipse Java compiler knows about this project:

```rascal-shell
rascal>myModel = createM3FromEclipseProject(|project://example-project|);
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(10,26,<1,10>,<1,36>): Undeclared variable: createM3FromEclipseProject
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```

### Benefits 

*  Notice that _all_ these [$Rascal:Values/Location] literals are hyperlinks and you can click on them to go the source code that they point to. Try it!



## Measuring Classes {#Metrics-MeasuringJava-MeasuringClasses}





### Function 
       



### Examples 


```rascal-shell
```
First we import the basic data types for representing Java. The model is called _M3_, and its definition is split acros a generic
language independent module called [Rascal:analysis/m3/Core] and a Java specific part called [Rascal:lang/java/m3/Core]. Have a look at the documentation 
of these modules later. For now we will go through using them in a few examples.

```rascal-shell
rascal>import lang::java::m3::Core;
ok
```
Then we import the API for extracting an M3 model from an Eclipse project. 

```rascal-shell
rascal>import lang::java::jdt::m3::Core;
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(0,33,<1,0>,<1,33>): Could not import module lang::java::jdt::m3::Core: can not find in search path
Advice: |http://tutor.rascal-mpl.org/Errors/Static/ModuleImport/ModuleImport.html|
</pre>
:::

```rascal-shell
ok
```
Calling the following function generates an enormous value representing everything the Eclipse Java compiler knows about this project:

```rascal-shell
rascal>myModel = createM3FromEclipseProject(|project://example-project|);
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(10,26,<1,10>,<1,36>): Undeclared variable: createM3FromEclipseProject
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
Next, let's focus on the _containment_ relation. This defines what parts of the source code are parts of which other parts:

```rascal-shell
rascal>myModel.containment
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(0,7,<1,0>,<1,7>): Undeclared variable: myModel
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
As you can read, classes contain methods, methods contain variables, etc. Classes could also contain other classes (nested classes), and methods can even contain classes (anonymous classes). Let's focus on a specific class, and project what it contains from the relation:

```rascal-shell
rascal>myModel.containment[|java+class:///HelloWorld|]
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(0,7,<1,0>,<1,7>): Undeclared variable: myModel
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
Let's filter the methods:

```rascal-shell
rascal>helloWorldMethods = [ e | e <- myModel.containment[|java+class:///HelloWorld|], e.scheme == "java+method"];
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(31,7,<1,31>,<1,38>): Undeclared variable: myModel
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
And we are ready to compute our first metric. How many methods does this class contain?

```rascal-shell
rascal>import List;
ok
rascal>size(helloWorldMethods)
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(5,17,<1,5>,<1,22>): Undeclared variable: helloWorldMethods
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
No magic applied! It is just a little query on a model that knows everything about the code. Let's generalize and compute the number of methods for all classes in one big expression. First a function to compute the number for a given class:

```rascal-shell
rascal>int numberOfMethods(loc cl, M3 model) = size([ m | m <- model.containment[cl], isMethod(m)]);
int (loc, M3): function(|prompt:///|(0,93,<1,0>,<1,93>))
```
then we apply this new function to give us a map from classes to integers:

```rascal-shell
rascal>map[loc class, int methodCount] numberOfMethodsPerClass = (cl:numberOfMethods(cl, myModel) | <cl,_> <- myModel.containment, isClass(cl));
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(103,7,<1,103>,<1,110>): Undeclared variable: myModel
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
how about the number of fields?

```rascal-shell
rascal>int numberOfFields(loc cl, M3 model) = size([ m | m <- model.containment[cl], isField(m)]);
int (loc, M3): function(|prompt:///|(0,91,<1,0>,<1,91>))
rascal>map[loc class, int fieldCount] numberOfFieldsPerClass = (cl:numberOfFields(cl, myModel) | <cl,_> <- myModel.containment, isClass(cl));
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(100,7,<1,100>,<1,107>): Undeclared variable: myModel
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
what is the ratio between fields and methods for each class?

```rascal-shell
rascal>(cl : (numberOfFieldsPerClass[cl] * 1.0) / (numberOfMethodsPerClass[cl] * 1.0) | cl <- classes(myModel))
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(95,7,<1,95>,<1,102>): Undeclared variable: myModel
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```




## Measuring Methods {#Metrics-MeasuringJava-MeasuringMethods}





### Function 
       



### Examples 


```rascal-shell
rascal>import lang::java::m3::Core;
ok
rascal>import lang::java::jdt::m3::Core;
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(0,33,<1,0>,<1,33>): Could not import module lang::java::jdt::m3::Core: can not find in search path
Advice: |http://tutor.rascal-mpl.org/Errors/Static/ModuleImport/ModuleImport.html|
</pre>
:::

```rascal-shell
ok
rascal>import lang::java::jdt::m3::AST;
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(0,32,<1,0>,<1,32>): Could not import module lang::java::jdt::m3::AST: can not find in search path
Advice: |http://tutor.rascal-mpl.org/Errors/Static/ModuleImport/ModuleImport.html|
</pre>
:::

```rascal-shell
ok
```
First extract our overview model

```rascal-shell
rascal>myModel = createM3FromEclipseProject(|project://example-project|);
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(10,26,<1,10>,<1,36>): Undeclared variable: createM3FromEclipseProject
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
Now let's focus on the methods

```rascal-shell
rascal>myMethods = methods(myModel);
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(20,7,<1,20>,<1,27>): Undeclared variable: myModel
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
What is the source code for a method?

```rascal-shell
rascal>import IO;
ok
rascal>methodSrc = readFile(|java+method:///HelloWorld/main(java.lang.String%5B%5D)|);
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|std:///IO.rsc|(12501,1714,<532,0>,<568,24>): IO("Unsupported scheme \'java+method\'")
	at *** somewhere ***(|std:///IO.rsc|(12501,1714,<532,0>,<568,24>))
	at readFile(|prompt:///|(21,56,<1,21>,<1,77>))
</pre>
:::

```rascal-shell
ok
```
let's print it:

```rascal-shell
rascal>println(methodSrc)
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(8,9,<1,8>,<1,17>): Undeclared variable: methodSrc
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
how many words in this method?

```rascal-shell
rascal>(0 | it + 1 | /\W+/ := methodSrc)
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(23,9,<1,23>,<1,32>): Undeclared variable: methodSrc
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
let's get its AST

```rascal-shell
rascal>methodAST = getMethodASTEclipse(|java+method:///HelloWorld/main(java.lang.String%5B%5D)|, model=myModel);
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(12,19,<1,12>,<1,31>): Undeclared variable: getMethodASTEclipse
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
Now we count the number of expressions:

```rascal-shell
rascal>(0 | it + 1 | /Expression _ := methodAST)
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(31,9,<1,31>,<1,40>): Undeclared variable: methodAST
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
or give us the locations of all expressions:

```rascal-shell
rascal>[m@src | /Expression m := methodAST]
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(26,9,<1,26>,<1,35>): Undeclared variable: methodAST
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```
the size should be the same, right?

```rascal-shell
rascal>import List;
ok
rascal>size([m@src | /Expression m := methodAST]) == (0 | it + 1 | /Expression _ := methodAST)
```
:::danger
Rascal code execution failed (unexpectedly) during compilation of this documentation.
<pre>
|prompt:///|(31,9,<1,31>,<1,40>): Undeclared variable: methodAST
Advice: |http://tutor.rascal-mpl.org/Errors/Static/UndeclaredVariable/UndeclaredVariable.html|
</pre>
:::

```rascal-shell
ok
```




## Basic {#Basic-Basic}

### Synopsis 
Some basic, _hello world_-like, examples of Rascal programs.




### Details 
Hello Factorial Squares

### Description 
We discuss the following examples:
* _broken:Recipes:Basic-Quine (ambiguous link)_
* _broken:Recipes:Basic-Even (ambiguous link)_
* _broken:Recipes:Basic-Factorial (ambiguous link)_
* _broken:Recipes:Basic-Bubble (ambiguous link)_
* _broken:Recipes:Basic-Hello (ambiguous link)_
* _broken:Recipes:Basic-Squares (ambiguous link)_
* _broken:Recipes:Basic-FizzBuzz (ambiguous link)_
* _broken:Recipes:Basic-BottlesOfBeer (ambiguous link)_




### Pitfalls 
These programs illustrate various features of Rascal; they are *not representative* as use cases of the language.


## Quine {#Basic-Quine}

### Synopsis 
A self-reproducing program.





### Description 
A http://en.wikipedia.org/wiki/Quine_(computing)[quine]
is a computer program that takes no input and produces a copy of its own source code.
A quine is also called a _self-replicating_ or _self-reproducing_ program.

At the http://www.nyx.net/~gthompso/quine.htm[Quine Page] you can find hundreds of
quines in many different programming languages.

Learning about quines, is about learning how to quote and escape symbols in strings.


### Examples 

```rascal
include::{LibDir}demo/basic/Quine.rsc[]
```

                
<1> A remarkable point in the code: the string variable `program` has as value
   the text of the module `Quine` upto here. 
<2> The definition of `program` ends here.
    This string has a mesmerizing amount of escapes to which we will come back in a moment.

<3> The function `quine` prints the string `program` twice, here as is and this produces the program upto icon:callout[1] above.
<4> Here the value of `program` is printed as a string (surrounded with string quotes) in order to reproduce the string value 
    of `program` followed by a semi-colon (`;`).
  
Now here is the catch: we have to be very carefull in handling special characters like quote (`"`) and backslash (`\`) in strings.

Let's do a simple experiment:

```rascal-shell
rascal>import IO;
ok
rascal>str greeting = "\"Good Morning, Dr. Watson\", said Holmes";
str: "\"Good Morning, Dr. Watson\", said Holmes"
rascal>println("\"" + greeting + "\"");
println("\"" + greeting + "\"");
""Good Morning, Dr. Watson", said Holmes"
ok
```
As you see the quotes inside the string are not escaped and the result is not a legal string.
So what can we do? We escape all dangerous characters in the string before printing it using the [Rascal:escape] function.
It takes a string and a map of characters to be escaped and returns a result in which all escaping has been carried out.
Be aware that in the map, also escaping is needed!
We want to say: escape `"` and replace it by `\"`, but since both `"` and `\` have to be escaped themselves
we have to say: escape `"\""` and replace it by `"\\\""`. The effect is as follows:

```rascal-shell
rascal>import String;
ok
rascal>println("\"" + escape(greeting, ("\"": "\\\"")) + "\"");
println("\"" + escape(greeting, ("\"": "\\\"")) + "\"");
"\"Good Morning, Dr. Watson\", said Holmes"
ok
```
And indeed, the two quotes are now properly escaped.

This is exactly what happens at image:{images}/4.png[] in the definition of `quine`:
```rascal
println("\"" + escape(program, ("\"" : "\\\"", "\\" : "\\\\")) + "\";");
```
We escape `program` and replace `"` by `\"`, and `\` by `\\`.
The mesmerizing amount of `\` characters can be explained due to escaping `"` and `\`.

Now let's put `quine` to the test.

```rascal-shell
rascal>import demo::basic::Quine;
ok
rascal>quine();
quine();
module demo::basic::Quine

import IO;
import String;

void quine(){
  println(program);
  println("\"" + escape(program, ("\"" : "\\\"", "\\" : "\\\\")) + "\";");
}

str program =
"module demo::basic::Quine

import IO;
import String;

void quine(){
  println(program);
  println(\"\\\"\" + escape(program, (\"\\\"\" : \"\\\\\\\"\", \"\\\\\" : \"\\\\\\\\\")) + \"\\\";\");
}

str program =";
ok
```
If you follow this output line-by-line you will see that it
is identical to the original source code of module `Quine`.




## Even {#Basic-Even}

### Synopsis 
Produce a list of even numbers.





### Description 

Let's write a function that generates all the even numbers in a list up to a certain maximum. We will do it in a few alternative 
ways: from very imperative to very declarative and some steps in between.


```rascal-shell
rascal>list[int] even0(int max) {
>>>>>>>  list[int] result = [];
>>>>>>>  for (int i <- [0..max])
>>>>>>>    if (i % 2 == 0)
>>>>>>>      result += i;
>>>>>>>  return result;
>>>>>>>}
list[int] (int): function(|prompt:///|(0,135,<1,0>,<7,1>))
rascal>even0(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]
```
Now lets remove the temporary type declarations:

```rascal-shell
rascal>list[int] even1(int max) {
>>>>>>>  result = [];
>>>>>>>  for (i <- [0..max])
>>>>>>>    if (i % 2 == 0)
>>>>>>>      result += i;
>>>>>>>  return result;
>>>>>>>}
list[int] (int): function(|prompt:///|(0,121,<1,0>,<7,1>))
rascal>even1(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]
```
To make the code shorter, we can inline the condition in the for loop:

```rascal-shell
rascal>list[int] even2(int max) {
>>>>>>>  result = [];
>>>>>>>  for (i <- [0..max], i % 2 == 0)
>>>>>>>    result += i;
>>>>>>>  return result;
>>>>>>>}
list[int] (int): function(|prompt:///|(0,111,<1,0>,<6,1>))
rascal>even2(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]
```
In fact, for loops may produce lists as values, using the append statement:

```rascal-shell
rascal>list[int] even3(int max) {
>>>>>>>  result = for (i <- [0..max], i % 2 == 0)
>>>>>>>    append i;
>>>>>>>  return result;
>>>>>>>}
list[int] (int): function(|prompt:///|(0,102,<1,0>,<5,1>))
rascal>even3(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]
```
So now, the result temporary is not necessary anymore:

```rascal-shell
rascal>list[int] even4(int max) {
>>>>>>>  return for (i <- [0..max], i % 2 == 0)
>>>>>>>           append i;
>>>>>>>}
list[int] (int): function(|prompt:///|(0,90,<1,0>,<4,1>))
rascal>even4(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]
```
This code is actually very close to a list comprehension already:

```rascal-shell
rascal>list[int] even5(int max) {
>>>>>>>  return [ i | i <- [0..max], i % 2 == 0];
>>>>>>>}
list[int] (int): function(|prompt:///|(0,71,<1,0>,<3,1>))
rascal>even5(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]
```
And now we can just define `even` using an expression only:

```rascal-shell
rascal>list[int] even6(int max) = [i | i <- [0..max], i % 2 == 0];
list[int] (int): function(|prompt:///|(0,59,<1,0>,<1,59>))
rascal>even6(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]
```
Or, perhaps we prefer creating a set instead of a list:

```rascal-shell
rascal>set[int] even7(int max) = {i | i <- [0..max], i % 2 == 0};
set[int] (int): function(|prompt:///|(0,58,<1,0>,<1,58>))
rascal>even7(25);
set[int]: {10,16,8,14,20,2,4,6,24,12,22,18,0}
```


### Benefits 

*  You can program in for loops and use temporary variables if you like.
*  Comprehensions are shorter and more powerful.
*  There are comprehensions for lists, sets, and maps

### Pitfalls 

*  Trainwreck alert: if you start putting too many conditions in a single for loop or comprehension the code may become unreadable.


## Factorial {#Basic-Factorial}

### Synopsis 
Compute the factorial function.






### Examples 
The http://en.wikipedia.org/wiki/Factorial[factorial]
of a number N is defined as `N * (N-1) * (N-2) * ... * 1`.
Here is the Rascal version:
```rascal
include::{LibDir}demo/basic/Factorial.rsc[tags=module]
```
          
<1> `fac` is defined using a conditional expression to distinguish cases.
<2> `fac2` distinguishes cases using pattern-based dispatch ([Rascal Functions]_Rascal:Concepts-Function (broken link)_).
    Here the case for `0` is defined.
<3> Here all other cases for `fac2` are defined (as indicated by the `default` keyword).
<4> `fac3` shows a more imperative implementation of factorial.

Here is how to use `fac`:


```rascal-shell
rascal>import demo::basic::Factorial;
ok
rascal>fac(47);
int: 258623241511168180642964355153611979969197632389120000000000
```

NOTE: Indeed, Rascal supports arbitrary length numbers.
 
Here is an example of `fac2`:

```rascal-shell
rascal>fac2(47);
int: 258623241511168180642964355153611979969197632389120000000000
```




## Bubble {#Basic-Bubble}

### Synopsis 
Variout styles to write bubble sort.





### Description 
http://en.wikipedia.org/wiki/Bubble_sort[Bubble sort] is a classical (albeit not the most efficient) technique to sort lists of values.
We present here several styles to implement bubble sort. 
Also see [sort]_Libraries:List-sort (broken link)_ for a more efficient library function for sorting.

### Examples 
```rascal
include::{LibDir}demo/basic/Bubble.rsc[tags=module]
```
                
`sort1` is a classic, imperative style, implementation of bubble sort: it iterates over consecutive pairs of elements and
when a not-yet-sorted pair is encountered, the elements are exchanged, and `sort1` is applied recursively to the whole list.

`sort2` uses list matching and consists of a switch with two cases:

*  a case matching a list with two consecutive elements that are unsorted. Observe that when the pattern of a case matches,
   the case as a whole can still fail.
*  a default case.


`sort3` also uses list matching but in a more declarative style: as long as there are unsorted elements in the list (possibly with intervening elements), exchange them.

`sort4` is identical to `sort3`, except that the shorter `*`-notation for list variables is used and that the type declaration for the
the non-list variables has been omitted.

`sort5` uses tail recursion to reach a fixed point instead of a while loop. One alternative matches lists with out-of-order elements, while the default alternative returns the list if no out-of-order elements are found.

Let's put them to the test:

```rascal-shell
rascal>import demo::basic::Bubble;
ok
rascal>L = [9,8,7,6,5,4,3,2,1];
list[int]: [9,8,7,6,5,4,3,2,1]
rascal>sort1(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal>sort2(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal>sort3(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal>sort4(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal>sort5(L);
list[int]: [1,2,3,4,5,6,7,8,9]
```





## Hello {#Basic-Hello}

### Synopsis 
Variations on the ubiquitous _Hello World_ example.






### Examples 
##  `hello` on command line 


We demonstrate hello via an interactive session with the Rascal system. First we get the prompt `rascal>` that shows that Rascal is ready for our input. 
Next, we import the library module [IO]_Libraries:Prelude-IO (broken link)_ since hello world requires printing. Rascal responds with the feedback `ok` so we know that all went well. Finally, we call `println` and proudly observe our first Rascal output!

```rascal-shell
rascal>import IO;
ok
rascal>println("Hello world, this is my first Rascal program");
println("Hello world, this is my first Rascal program");
Hello world, this is my first Rascal program
ok
```

##  `hello` as function 


A slightly more audacious approach is to wrap the print statement in a function and call it:

```rascal-shell
rascal>import IO;
ok
rascal>void hello() {
>>>>>>>   println("Hello world, this is my first Rascal program");
>>>>>>>}
void (): function(|prompt:///|(0,76,<1,0>,<3,1>))
```
When you type in a command and continue it on a new line 
the Rascal systems prompts you with `>>>>>>>` to 
indicate that more input is needed. Don't get scared by 
the `void (): void hello();` that you get back 
when typing in the hello function. The first 
`void ()` part says the result is a function that 
returns nothing, and the second part 
`void hello()` summarizes its value 
(or would you prefer a hex dump?).
Finally, we call the `hello` function and enjoy its output.

```rascal-shell
rascal>hello();
hello();
Hello world, this is my first Rascal program
ok
```

##  `hello` as module 

The summit of hello-engineering can be reached by placing all the above in a separate module:

```rascal
include::{LibDir}demo/basic/Hello.rsc[tags=module]
```

This module should be placed in `<project dir>/src/demo/basic/Hello.rsc`.

Using this Hello module is now simple:


```rascal-shell
rascal>import demo::basic::Hello;
ok
rascal>hello();
hello();
Hello world, this is my first Rascal program
ok
```

The `hello` function is by default visible outside the `Hello` module.
We could stress this by adding writing `public void hello() { ... }`.
Restricting visibility to the module itself can be achieved by adding the keyword `private`
to the definition of `hello`.




## Squares {#Basic-Squares}

### Synopsis 
Print a list of squares






### Examples 
How can we print a list of squares? Here is a solution:
```rascal
include::{LibDir}demo/basic/Squares.rsc[tags=module]
```
           
<1> The [IO]_Libraries:Prelude-IO (broken link)_ module is imported since we want to print things using `println`.

<2> [String](/Rascal.md#Expressions-Values-String) interpolation is used several times.
    Here the value of `N` is inserted in the header message.

<3> The values of `I` and `I * I` are inserted in each line that is printed.

<4> Define an alternative implementation `squareTemplate` that is based on string templates 
    and returns a string value instead of printing the results itself.

Here is how `square` can be used:

```rascal-shell
rascal>import demo::basic::Squares;
ok
rascal>squares(9);
squares(9);
Table of squares from 1 to 9

1 squared = 1
2 squared = 4
3 squared = 9
4 squared = 16
5 squared = 25
6 squared = 36
7 squared = 49
8 squared = 64
9 squared = 81
ok
```

`squaresTemplate` gives a similar result but now as a string:

```rascal-shell
rascal>squaresTemplate(9);
str: "Table of squares from 1 to 9\n\n  1 squared = 1\n  2 squared = 4\n  3 squared = 9\n  4 squared = 16\n  5 squared = 25\n  6 squared = 36\n  7 squared = 49\n  8 squared = 64\n  9 squared = 81"
```

To get a truly identical result we have to import the [IO]_Libraries:Prelude-IO (broken link)_ module 
and print the value of `squaresTemplate`:

```rascal-shell
rascal>import IO;
ok
rascal>println(squaresTemplate(9));
println(squaresTemplate(9));
Table of squares from 1 to 9

  1 squared = 1
  2 squared = 4
  3 squared = 9
  4 squared = 16
  5 squared = 25
  6 squared = 36
  7 squared = 49
  8 squared = 64
  9 squared = 81
ok
```





## FizzBuzz {#Basic-FizzBuzz}

### Synopsis 
We solve a well-known job interview puzzle.





### Description 

http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html[FizzBuzz] is a well-known puzzle that is used at job interviews.
It is defined as follows:

  Write a program that prints the numbers from 1 to 100. 
  But for multiples of three print "Fizz" instead of the number and for the multiples of five print "Buzz". 
  For numbers which are multiples of both three and five print "FizzBuzz".

Surprisingly, many candidates fail to pass this test.
Solutions to FizzBuzz in various languages are available http://www.geekschool.org/programming/fizzbuzz/[here].

### Examples 
Here are a few possible Rascal solutions:
```rascal
include::{LibDir}demo/basic/FizzBuzz.rsc[tags=module]
```


```rascal-shell
rascal>import demo::basic::FizzBuzz;
ok
rascal>fizzbuzz();
fizzbuzz();
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
ok
```




## Bottles Of Beer {#Basic-BottlesOfBeer}

### Synopsis 
A Rascal version of a generator for the _99 Bottles of Beer_ song.





### Description 
Programs that generate the lyrics for the song _99 Bottles of Beer_ are a popular way to compare programming languages.
At http://99-bottles-of-beer.net/[99-bottles-of-beer.net] you can find versions in nearly 1500 different languages
and the lyrics can be found http://99-bottles-of-beer.net/lyrics.html[here].

### Examples 
Here is our version:
```rascal
include::{LibDir}demo/basic/Bottles.rsc[tags=module]
```

                
<1> We use an auxiliary function `bottles` that returns the word "bottle" adjusted for the actual number of bottles that is available.
Observe how we use the patterns `0`, `1` and `int n` in the definition of three variants of this function.

<2> _Pattern-directed invocation_ (see [function declaration]_broken:Rascal:Declarations-Function (ambiguous link)_) will determine at the call site which function will be called. The
general case is labeled with `default` to indicate that if the case for 0 and 1 do not match, this alternative should handle the other cases. 

<3> The main function is `sing` that iterates over the numbers 99 down to 1 (as described by the range `[99 .. 0]`)
and prints appropriate lyrics. Observe how the value  of the `bottles` function is interpolated several times in the string.

Here is the result:


```rascal-shell
rascal>import demo::basic::Bottles;
ok
rascal>sing();
sing();
99 bottles of beer on the wall, 99 bottles of beer.
Take one down, pass it around, 98 bottles of beer on the wall.

98 bottles of beer on the wall, 98 bottles of beer.
Take one down, pass it around, 97 bottles of beer on the wall.

97 bottles of beer on the wall, 97 bottles of beer.
Take one down, pass it around, 96 bottles of beer on the wall.

96 bottles of beer on the wall, 96 bottles of beer.
Take one down, pass it around, 95 bottles of beer on the wall.

95 bottles of beer on the wall, 95 bottles of beer.
Take one down, pass it around, 94 bottles of beer on the wall.

94 bottles of beer on the wall, 94 bottles of beer.
Take one down, pass it around, 93 bottles of beer on the wall.

93 bottles of beer on the wall, 93 bottles of beer.
Take one down, pass it around, 92 bottles of beer on the wall.

92 bottles of beer on the wall, 92 bottles of beer.
Take one down, pass it around, 91 bottles of beer on the wall.

91 bottles of beer on the wall, 91 bottles of beer.
Take one down, pass it around, 90 bottles of beer on the wall.

90 bottles of beer on the wall, 90 bottles of beer.
Take one down, pass it around, 89 bottles of beer on the wall.

89 bottles of beer on the wall, 89 bottles of beer.
Take one down, pass it around, 88 bottles of beer on the wall.

88 bottles of beer on the wall, 88 bottles of beer.
Take one down, pass it around, 87 bottles of beer on the wall.

87 bottles of beer on the wall, 87 bottles of beer.
Take one down, pass it around, 86 bottles of beer on the wall.

86 bottles of beer on the wall, 86 bottles of beer.
Take one down, pass it around, 85 bottles of beer on the wall.

85 bottles of beer on the wall, 85 bottles of beer.
Take one down, pass it around, 84 bottles of beer on the wall.

84 bottles of beer on the wall, 84 bottles of beer.
Take one down, pass it around, 83 bottles of beer on the wall.

83 bottles of beer on the wall, 83 bottles of beer.
Take one down, pass it around, 82 bottles of beer on the wall.

82 bottles of beer on the wall, 82 bottles of beer.
Take one down, pass it around, 81 bottles of beer on the wall.

81 bottles of beer on the wall, 81 bottles of beer.
Take one down, pass it around, 80 bottles of beer on the wall.

80 bottles of beer on the wall, 80 bottles of beer.
Take one down, pass it around, 79 bottles of beer on the wall.

79 bottles of beer on the wall, 79 bottles of beer.
Take one down, pass it around, 78 bottles of beer on the wall.

78 bottles of beer on the wall, 78 bottles of beer.
Take one down, pass it around, 77 bottles of beer on the wall.

77 bottles of beer on the wall, 77 bottles of beer.
Take one down, pass it around, 76 bottles of beer on the wall.

76 bottles of beer on the wall, 76 bottles of beer.
Take one down, pass it around, 75 bottles of beer on the wall.

75 bottles of beer on the wall, 75 bottles of beer.
Take one down, pass it around, 74 bottles of beer on the wall.

74 bottles of beer on the wall, 74 bottles of beer.
Take one down, pass it around, 73 bottles of beer on the wall.

73 bottles of beer on the wall, 73 bottles of beer.
Take one down, pass it around, 72 bottles of beer on the wall.

72 bottles of beer on the wall, 72 bottles of beer.
Take one down, pass it around, 71 bottles of beer on the wall.

71 bottles of beer on the wall, 71 bottles of beer.
Take one down, pass it around, 70 bottles of beer on the wall.

70 bottles of beer on the wall, 70 bottles of beer.
Take one down, pass it around, 69 bottles of beer on the wall.

69 bottles of beer on the wall, 69 bottles of beer.
Take one down, pass it around, 68 bottles of beer on the wall.

68 bottles of beer on the wall, 68 bottles of beer.
Take one down, pass it around, 67 bottles of beer on the wall.

67 bottles of beer on the wall, 67 bottles of beer.
Take one down, pass it around, 66 bottles of beer on the wall.

66 bottles of beer on the wall, 66 bottles of beer.
Take one down, pass it around, 65 bottles of beer on the wall.

65 bottles of beer on the wall, 65 bottles of beer.
Take one down, pass it around, 64 bottles of beer on the wall.

64 bottles of beer on the wall, 64 bottles of beer.
Take one down, pass it around, 63 bottles of beer on the wall.

63 bottles of beer on the wall, 63 bottles of beer.
Take one down, pass it around, 62 bottles of beer on the wall.

62 bottles of beer on the wall, 62 bottles of beer.
Take one down, pass it around, 61 bottles of beer on the wall.

61 bottles of beer on the wall, 61 bottles of beer.
Take one down, pass it around, 60 bottles of beer on the wall.

60 bottles of beer on the wall, 60 bottles of beer.
Take one down, pass it around, 59 bottles of beer on the wall.

59 bottles of beer on the wall, 59 bottles of beer.
Take one down, pass it around, 58 bottles of beer on the wall.

58 bottles of beer on the wall, 58 bottles of beer.
Take one down, pass it around, 57 bottles of beer on the wall.

57 bottles of beer on the wall, 57 bottles of beer.
Take one down, pass it around, 56 bottles of beer on the wall.

56 bottles of beer on the wall, 56 bottles of beer.
Take one down, pass it around, 55 bottles of beer on the wall.

55 bottles of beer on the wall, 55 bottles of beer.
Take one down, pass it around, 54 bottles of beer on the wall.

54 bottles of beer on the wall, 54 bottles of beer.
Take one down, pass it around, 53 bottles of beer on the wall.

53 bottles of beer on the wall, 53 bottles of beer.
Take one down, pass it around, 52 bottles of beer on the wall.

52 bottles of beer on the wall, 52 bottles of beer.
Take one down, pass it around, 51 bottles of beer on the wall.

51 bottles of beer on the wall, 51 bottles of beer.
Take one down, pass it around, 50 bottles of beer on the wall.

50 bottles of beer on the wall, 50 bottles of beer.
Take one down, pass it around, 49 bottles of beer on the wall.

49 bottles of beer on the wall, 49 bottles of beer.
Take one down, pass it around, 48 bottles of beer on the wall.

48 bottles of beer on the wall, 48 bottles of beer.
Take one down, pass it around, 47 bottles of beer on the wall.

47 bottles of beer on the wall, 47 bottles of beer.
Take one down, pass it around, 46 bottles of beer on the wall.

46 bottles of beer on the wall, 46 bottles of beer.
Take one down, pass it around, 45 bottles of beer on the wall.

45 bottles of beer on the wall, 45 bottles of beer.
Take one down, pass it around, 44 bottles of beer on the wall.

44 bottles of beer on the wall, 44 bottles of beer.
Take one down, pass it around, 43 bottles of beer on the wall.

43 bottles of beer on the wall, 43 bottles of beer.
Take one down, pass it around, 42 bottles of beer on the wall.

42 bottles of beer on the wall, 42 bottles of beer.
Take one down, pass it around, 41 bottles of beer on the wall.

41 bottles of beer on the wall, 41 bottles of beer.
Take one down, pass it around, 40 bottles of beer on the wall.

40 bottles of beer on the wall, 40 bottles of beer.
Take one down, pass it around, 39 bottles of beer on the wall.

39 bottles of beer on the wall, 39 bottles of beer.
Take one down, pass it around, 38 bottles of beer on the wall.

38 bottles of beer on the wall, 38 bottles of beer.
Take one down, pass it around, 37 bottles of beer on the wall.

37 bottles of beer on the wall, 37 bottles of beer.
Take one down, pass it around, 36 bottles of beer on the wall.

36 bottles of beer on the wall, 36 bottles of beer.
Take one down, pass it around, 35 bottles of beer on the wall.

35 bottles of beer on the wall, 35 bottles of beer.
Take one down, pass it around, 34 bottles of beer on the wall.

34 bottles of beer on the wall, 34 bottles of beer.
Take one down, pass it around, 33 bottles of beer on the wall.

33 bottles of beer on the wall, 33 bottles of beer.
Take one down, pass it around, 32 bottles of beer on the wall.

32 bottles of beer on the wall, 32 bottles of beer.
Take one down, pass it around, 31 bottles of beer on the wall.

31 bottles of beer on the wall, 31 bottles of beer.
Take one down, pass it around, 30 bottles of beer on the wall.

30 bottles of beer on the wall, 30 bottles of beer.
Take one down, pass it around, 29 bottles of beer on the wall.

29 bottles of beer on the wall, 29 bottles of beer.
Take one down, pass it around, 28 bottles of beer on the wall.

28 bottles of beer on the wall, 28 bottles of beer.
Take one down, pass it around, 27 bottles of beer on the wall.

27 bottles of beer on the wall, 27 bottles of beer.
Take one down, pass it around, 26 bottles of beer on the wall.

26 bottles of beer on the wall, 26 bottles of beer.
Take one down, pass it around, 25 bottles of beer on the wall.

25 bottles of beer on the wall, 25 bottles of beer.
Take one down, pass it around, 24 bottles of beer on the wall.

24 bottles of beer on the wall, 24 bottles of beer.
Take one down, pass it around, 23 bottles of beer on the wall.

23 bottles of beer on the wall, 23 bottles of beer.
Take one down, pass it around, 22 bottles of beer on the wall.

22 bottles of beer on the wall, 22 bottles of beer.
Take one down, pass it around, 21 bottles of beer on the wall.

21 bottles of beer on the wall, 21 bottles of beer.
Take one down, pass it around, 20 bottles of beer on the wall.

20 bottles of beer on the wall, 20 bottles of beer.
Take one down, pass it around, 19 bottles of beer on the wall.

19 bottles of beer on the wall, 19 bottles of beer.
Take one down, pass it around, 18 bottles of beer on the wall.

18 bottles of beer on the wall, 18 bottles of beer.
Take one down, pass it around, 17 bottles of beer on the wall.

17 bottles of beer on the wall, 17 bottles of beer.
Take one down, pass it around, 16 bottles of beer on the wall.

16 bottles of beer on the wall, 16 bottles of beer.
Take one down, pass it around, 15 bottles of beer on the wall.

15 bottles of beer on the wall, 15 bottles of beer.
Take one down, pass it around, 14 bottles of beer on the wall.

14 bottles of beer on the wall, 14 bottles of beer.
Take one down, pass it around, 13 bottles of beer on the wall.

13 bottles of beer on the wall, 13 bottles of beer.
Take one down, pass it around, 12 bottles of beer on the wall.

12 bottles of beer on the wall, 12 bottles of beer.
Take one down, pass it around, 11 bottles of beer on the wall.

11 bottles of beer on the wall, 11 bottles of beer.
Take one down, pass it around, 10 bottles of beer on the wall.

10 bottles of beer on the wall, 10 bottles of beer.
Take one down, pass it around, 9 bottles of beer on the wall.

9 bottles of beer on the wall, 9 bottles of beer.
Take one down, pass it around, 8 bottles of beer on the wall.

8 bottles of beer on the wall, 8 bottles of beer.
Take one down, pass it around, 7 bottles of beer on the wall.

7 bottles of beer on the wall, 7 bottles of beer.
Take one down, pass it around, 6 bottles of beer on the wall.

6 bottles of beer on the wall, 6 bottles of beer.
Take one down, pass it around, 5 bottles of beer on the wall.

5 bottles of beer on the wall, 5 bottles of beer.
Take one down, pass it around, 4 bottles of beer on the wall.

4 bottles of beer on the wall, 4 bottles of beer.
Take one down, pass it around, 3 bottles of beer on the wall.

3 bottles of beer on the wall, 3 bottles of beer.
Take one down, pass it around, 2 bottles of beer on the wall.

2 bottles of beer on the wall, 2 bottles of beer.
Take one down, pass it around, 1 bottle of beer on the wall.

1 bottle of beer on the wall, 1 bottle of beer.
Take one down, pass it around, no more bottles of beer on the wall.

No more bottles of beer on the wall, no more bottles of beer.
Go to the store and buy some more, 99 bottles of beer on the wall.
ok
```





## Languages {#Languages-Languages}

### Synopsis 
Definitions of several languages and their tools.





### Description 

Examples of several languages and the implementation of tools like interpreters and compilers:
* _broken:Recipes:Languages-Pico (ambiguous link)_
* _broken:Recipes:Languages-Lisra (ambiguous link)_
* _broken:Recipes:Languages-Exp (ambiguous link)_
* _broken:Recipes:Languages-Func (ambiguous link)_

Other languages that we are considering (but are not yet described):

*  Oberon0: a scaled down version of the Oberon language.
*  MissGrant: a state machine language.






## Pico {#Languages-Pico}

### Synopsis 
The classical toy language, including a specialized IDE.



### Function 
       


### Description 

Pico is a toy language that has been used as example over the years in many projects and disguishes,
Pico has a single purpose in life: being so simple that specifications of every possible language aspect are so simple that they fit on a few pages. It can be summarized as follows:

*  There are two types: natural numbers and strings.

*  Variables have to be declared.

*  Statements are assignment, if-then-else and while-do.

*  Expressions may contain naturals, strings, variables, addition (`+`), subtraction (`-`) and concatenation (`||`).

*  The operators `+` and `-` have operands of type natural and their result is natural.

*  The operator `||` has operands of type string and its results is also of type string.

*  Tests in if-then-else statement and while-statement should be of type natural.


The following aspects of the Pico language will be discussed:

* [IDE](#Languages-Pico-IDE)
* [Abstract](#Languages-Pico-Abstract)
* [Assembly](#Languages-Pico-Assembly)
* [Use def](#Languages-Pico-UseDef)
* [Visualize](#Languages-Pico-Visualize)
* [Load](#Languages-Pico-Load)
* [Evaluate](#Languages-Pico-Evaluate)
* [Compile](#Languages-Pico-Compile)
* [Uninit](#Languages-Pico-Uninit)
* [Typecheck](#Languages-Pico-Typecheck)
* [Syntax](#Languages-Pico-Syntax)
* [Control flow](#Languages-Pico-ControlFlow)

### Examples 
Here is a -- not so simple -- Pico program that computes the factorial function:


```rascal
begin declare input : natural, // <1>
              output : natural,           
              repnr : natural,
              rep : natural;
      input := 14;
      output := 1;
      while input - 1 do // <2>
          rep := output;
          repnr := input;
          while repnr - 1 do
             output := output + rep;
             repnr := repnr - 1
          od;
          input := input - 1
      od
end
```

Notes:
	
<1> Pico programs do not have input/output statements, so we use variables for that purpose.
<2> Pico has no multiplication operator so we have to simulate it with repeated addition (yes, simplicity comes at a price!).






## IDE {#Languages-Pico-IDE}

### Synopsis 
An Integrated Development Environment for Pico.



### Function 
       



### Examples 
```rascal
include::{LibDir}demo/lang/Pico/Plugin.rsc[tags=module]
```

                
*  First the name of the language and its file name extension are defined (image:{images}/1.png).
*  Next the connection with the parser (image:{images}/2.png), checkers (image:{images}/3.png), evaluator (image:{images}/4.png),
  compiler (image:{images}/5.png), and visualizer (image:{images}/6.png) are defined.
*  (image:{images}/7.png) combines the above into a set of contributions to the Pico IDE.
*  The actual creation of the Pico IDE is done by `registerPico` (image:{images}/8.png) that:
   **  Registers the Pico language with name, file name extension and Parser. Whenever a user clicks on
       a `.pico` file an editor will opened and the parsed file will be displayed in it.
   **  Registers _annotators_ for Pico programs. Annotators run whenever a change is made to a Pico program in an open editor.
   **  Registers contributions to the context menu in the editor. When the user right-clicks, the context menu
       pops up and it will show a Pico entry with actions defined in the contributions.


Let's write a Pico program that produces a string of "a"s:


![](/assets/f604d65f-271b-4e6d-8071-2b1537fc7ad7.png)


As can be seen in the editor above, we get an error since we made a typo (missing comma) in the declarations. We correct it:



![](/assets/ba8bf80c-5ad1-48d4-9f02-4b18d439d3d7.png)


Now it turns out that we had erroneously used the `+` operator on strings (it should be `||`). We correct it:


![]_broken:Screenshot3.png (ambiguous link)_


Now we get a warning that variable `n` is not initialized. We correct it and get an error-free and warning-free program:


![](/assets/a4f43f4a-e889-4563-b38a-16a6248bbc1c.png)





## Abstract {#Languages-Pico-Abstract}

### Synopsis 
Abstract syntax for Pico.



### Function 
       



### Examples 
Here is the complete abstract syntax for Pico:

```rascal
include::{LibDir}demo/lang/Pico/Abstract.rsc[tags=module]
```

                
Notes:

<1> The types that may occur in a Pico program are either natural or string.
<2> Introduce `PicoId` as an alias for Rascal's `str` datatype.
<3> Define the various data types that constitute an AST for Pico. Observe that the constructor names match the names used in the concrete syntax, e.g., `strCon`, `add`, `ifElseStat`.
<4> Define an annotation with name `location` and of type `loc` (source code location) for all AST types. This will be used when imploding
    a parse tree into an abstract syntax tree.
<5> Introduce `Occurrence` as a genereic way of describing the location of various items in the AST.




## Assembly {#Languages-Pico-Assembly}

### Synopsis 
Assembly language for Pico.



### Function 
       



### Examples 
The [Compile](#Languages-Pico-Compile)r will translate Pico programs into the following assembly language.
```rascal
include::{LibDir}demo/lang/Pico/Assembly.rsc[tags=module]
```

                



## UseDef {#Languages-Pico-UseDef}

### Synopsis 
Compute use-def information for the variables in a Pico program.



### Function 
       



### Examples 
The _definitions_ of a variable are the source code locations where a variable gets a value.
The _uses_ of a variable are the location where the value of that variable is used.
Both concepts are relevant for program analysis and are defined here.
```rascal
include::{LibDir}demo/lang/Pico/UseDef.rsc[tags=module]
```

                
Recall that `Occurrence` was introduced in [Abstract](#Languages-Pico-Abstract); it is a parameterized container to associate
program entities with their location.

<1> The function `usesExp` computes a set of occurrences (uses) of Pico identifiers in a given statement:
    * If the expression is itself an identifier, then a singleton set containing that identifier and the statement is returned.
    * If the expression is composite, all its containing identifiers are collected using a descendant (deep) match 
       (`/`, see [Rascal:Descendant]))  in `/u:id(PicoId Id) \<- e`. 
        Note that we use a labeled pattern `u:id(PicoId Id)`,
       so that we can access the whole expression that was matched and retrieve its 
       location information (`u@location`) when we are adding a <location, identifier> pair to the set of occurrences.
       
<2> `useStat` extracts uses from all statement variants.

<3> The function `uses` simply applies `usesStats` to the statement part of its program argument.

<4> The function `defs`  has a Pico program as argument and returns a set of occurrences (definitions) of Pico identifiers.
    The definition consists of a single set comprehension that consists of the following parts:

    *  ` ... \<- P. stats` enumerates all statements in the program.
    *  `/asgStat(PicoId Id, EXP Exp) \<- P.stats` uses again a descendant match to find all assignment statements.
    *  For each assignment statement a (location, identifier) pair is added to the result.




## Visualize {#Languages-Pico-Visualize}

### Synopsis 
Visualize Pico Control Flow Graphs.



### Function 
       


### Description 

WARNING: The visualization library is being reimplemented and reorganized; 
the information provided here maybe inaccurate or even incorrect.

### Examples 
```rascal
include::{LibDir}demo/lang/Pico/Visualize.rsc[tags=module]
```

<1> We want to include the text of expressions in the relevant Figure nodes, this is achieved by `make`.
<2> An editor property is attached to each Figure node: clicking on the node opens an editor for the corresponding file.
<3> `visNode` implements the visualization per CFG node.
<4> Since Figure nodes in a visual graph need an `id` property, we define here a scheme to associate unique identifiers to each Figure node.
<5> The complete visualization of a CFG is implemented by `visCFG`: it gets the CFG graph as arguments and then
    *  creates all Figure edges,
    *  creates all Figure nodes,
    *  returns a Figure graph.


Let's now apply this:
```rascal-figure,width=,height=,file=cfg1.png
                import demo::lang::Pico::ControlFlow;
import demo::lang::Pico::Visualize;
CFG = cflowProgram("begin declare n : natural, s : string; n := 10; s := \"a\"; while n do s := s + \"a\"; n := n - 1 od end");
render(visCFG(CFG.graph));
```

The resulting visualization looks like this: 


![](/assets/74c94e2b-b257-4081-b9a4-f08bf2467ca1.png)




## Load {#Languages-Pico-Load}

### Synopsis 
Convert a Pico parse tree into a Pico abstract syntax tree.



### Function 
       



### Examples 
The mapping between parse tree and abstract sybtax tree is achieved as follows:
```rascal
include::{LibDir}demo/lang/Pico/Load.rsc[tags=module]
```

                
Notes:

*  The function `load` takes a string as argument (supposedly the source code of a Pico program) and returns a value of type `PROGRAM`,
the abstract syntax tree of the input program. In case the input program is syntactically incorrect, a `ParseError` exception will be thrown,
see [RuntimeException]_Libraries:Prelude-RunTimeException (broken link)_.

*  `parse(#Program, txt)`: parse `txt` according to the non-terminal `Program`. Note that `#Program` is a _reified type_, i.e., the type `Program` is represented as an ordinary Rascal value and passed as argument to the `parse` function,
see [reified types](/Rascal.md#Expressions-Values-ReifiedTypes).
The `parse` function returns a parse tree of the input program.

*  `implode(#PROGRAM, parse(#Program, txt))`: transform the parse returned by `parse` into an abstract syntax tree of type `PROGRAM`. The [$Rascal:implode] function performs the automatic mapping between elements in the parse tree and their counterpart in the abstract syntax.


The function `load` can be used as follows:

```rascal-shell
rascal>import demo::lang::Pico::Load;
ok
rascal>load("begin declare x : natural; x := 3 end");
PROGRAM: program(
[decl(
"x",
natural(
location=|unknown:///|(18,7,<1,18>,<1,25>),
comments=()),
location=|unknown:///|(14,11,<1,14>,<1,25>),
comments=())],
[asgStat(
"x",
natCon(
3,
location=|unknown:///|(32,1,<1,32>,<1,33>),
comments=()),
location=|unknown:///|(27,6,<1,27>,<1,33>),
comments=())],
location=|unknown:///|(0,37,<1,0>,<1,37>),
comments=())
```

Observe how the various parts of the abstract syntax tree are annotated with location attributes.




## Evaluate {#Languages-Pico-Evaluate}

### Synopsis 
Evaluate a Pico program.



### Function 
       



### Examples 

A complete evaluator (interpreter) for Pico is defined below.
```rascal
include::{LibDir}demo/lang/Pico/Eval.rsc[tags=module]
```

                
Notes:

<1> First we introduce a data type `PicoValue` that wraps all possible values that can occur at run-time.
<2> Compared to [Pico/Typecheck], we use `VENV`, a value environment (a map from Pico identifiers to Pico values).
*   The actual evaluator consists of the functions `evalExp`, `evalStat`, `evalStats`, `evalDecls` and `evalProgram`.
    They are written in a similar style as the typechecker.
*  `evalProgram` evaluates a given Pico program.


Here is how to evaluate a Pico program:

```rascal-shell
rascal>import demo::lang::Pico::Eval;
ok
rascal>evalProgram("begin declare x : natural, y : natural; x := 1; y := x + 5 end");
map[str, PicoValue]: (
"x":natval(1),
"y":natval(6)
)
```




## Compile {#Languages-Pico-Compile}

### Synopsis 
Compile a Pico program to assembly language.



### Function 
       



### Examples 

The Pico compiler translates Pico programs to [Assembly](#Languages-Pico-Assembly) language programs.

```rascal
include::{LibDir}demo/lang/Pico/Compile.rsc[tags=module]
```

                
Notes:

<1> We introduce `Instrs` as an alias for a list of assembly language instructions.
<2> The compiler consists of the functions `compileExp`, `compileStat`, `compileStats`, `compileDecls` and `compileProgram`.
    They all have a program fragment as argument and return the corresponding list of instructions.
<3> When compiling expressions, note how _list splicing_ (see [Rascal:Values/List]) is used to insert the instructions that are generated for the operands of an operator into the list of instructions for the whole expression.
<4> In order to conveniently write code generators for statements, we introduce a unique label generator. The global variable `nLabel` contains
    the index of the last generated label and `nextLabel` uses this to generate a new, unique label.

<5> Consider code generation for an if-the-else statement:
    *  Two fresh labels mark the start of the code for the else part (`elseLab`) and the end of the whole statement (`endLab`).
    *  The code that is generated consists of the following:
        ***  Code for the test.
        ***  A gofalse to the code for the else-part.
        ***  Code for the then-part and a jump to the end of the statement.
        ***  Code for the else-part that starts with the label `elsePart`.
        ***  The label `endLab` that marks the end of the code for the if-then-else statement.
<6>  Compiling a list of statements conveniently uses a list comprehension and list splicing.

<7>  Compiling declarations allocates memory locations of the appropriate type for each declared variable.

<8>  `compileProgram` compiles a gives Pico program to assembly language.


Here is an example:

```rascal-shell
rascal>import demo::lang::Pico::Compile;
ok
rascal>compileProgram("begin declare x : natural; x := 47 end");
list[Instr]: [
dclStr("x"),
lvalue("x"),
pushNat(47),
assign()
]
```
Here is the compilation of the factorial program:

```rascal-shell
rascal>compileProgram("begin declare input : natural,  
>>>>>>>               '              output : natural,           
>>>>>>>               '             repnr : natural,
>>>>>>>               '              rep : natural;
>>>>>>>               '      input := 14;
>>>>>>>               '      output := 1;
>>>>>>>               '      while input - 1 do        
>>>>>>>               '          rep := output;
>>>>>>>               '          repnr := input;
>>>>>>>               '          while repnr - 1 do
>>>>>>>               '             output := output + rep;
>>>>>>>               '             repnr := repnr - 1
>>>>>>>               '          od;
>>>>>>>               '          input := input - 1
>>>>>>>               '      od
>>>>>>>               'end");
list[Instr]: [
dclStr("input"),
dclStr("output"),
dclStr("repnr"),
dclStr("rep"),
lvalue("input"),
pushNat(14),
assign(),
lvalue("output"),
pushNat(1),
assign(),
label("L1"),
rvalue("input"),
pushNat(1),
sub2(),
gofalse("L2"),
lvalue("rep"),
rvalue("output"),
assign(),
lvalue("repnr"),
rvalue("input"),
assign(),
label("L3"),
rvalue("repnr"),
pushNat(1),
sub2(),
gofalse("L4"),
lvalue("output"),
rvalue("output"),
rvalue("rep"),
add2(),
assign(),
lvalue("repnr"),
rvalue("repnr"),
pushNat(1),
sub2(),
assign(),
go("L3"),
label("L4"),
lvalue("input"),
rvalue("input"),
pushNat(1),
sub2(),
assign(),
go("L1"),
label("L2")
]
```




## Uninit {#Languages-Pico-Uninit}

### Synopsis 
Find unitialized variables in a Pico program.



### Function 
       



### Examples 
Uninitialized variables are variables that are used without being initialized.
This means that there is a path in the control flow graph from the entry point of the program
to a specific use of a variable, where that path does not contain a definition of that variable.

This can be computed as follows:
```rascal
include::{LibDir}demo/lang/Pico/Uninit.rsc[tags=module]
```

                
<1> First, we determine the variable definitions of the program,
<2> and its control flow graph.
<3> Next we ask for every use of a variable the question: can it be reached from the entries
    of the program without encountering a definition? This determined as follows:

    *  `rangeR(D, {occ.item})` is the set of definition for the variable were are looking at. See [Rascal:Relation/rangeR].
    *  `reachX` determines the reachability in a graph while excluding certain nodes, see [Rascal:Graph/reachX]. Here
        `reachX(CFG.graph, CFG.entry, rangeR(D, {occ.item}))` determines the nodes in the graph that can be reached from the
         entry point of the program without passing a definition of the current variable.
    *  `any(CFNode N <- reachX( ... ), N has location && occ.location \<= N.location)` yields true if there is such a reachable node
        that covers the location of the current variable.
<4> The complete comprehension returns the set of occurrences of uninitialized variables.


The function `uninitProgram` performs this analysis on the source text of a Pico program.

Here is a simple example, where variable `p` is used without intialization:

```rascal-shell
rascal>import demo::lang::Pico::Uninit;
ok
rascal>uninitProgram("begin declare n : natural, m : natural, p : natural; n := 10; m := n + p end");
rel[loc location,str name,STATEMENT stat]: {<|unknown:///|(71,1,<1,71>,<1,72>),"p",asgStat(
"m",
add(
id(
"n",
location=|unknown:///|(67,1,<1,67>,<1,68>),
comments=()),
id(
"p",
location=|unknown:///|(71,1,<1,71>,<1,72>),
comments=()),
location=|unknown:///|(67,5,<1,67>,<1,72>),
comments=()),
location=|unknown:///|(62,10,<1,62>,<1,72>),
comments=())>}
```





## Typecheck {#Languages-Pico-Typecheck}

### Synopsis 
Typechecker for Pico programs.



### Function 
       



### Examples 

Recall the following properties of Pico that are relevant for type checking:

*  There are two types: natural numbers and strings.

*  Variables have to be declared.

*  Expressions may contain naturals, strings, variables, addition (`+`), subtraction (`-`) and concatenation (`||`).

*  The operators `+` and `-` have operands of type natural and their result is natural.

*  The operator `||` has operands of type string and its results is also of type string.

*  Tests in if-then-else statement and while-statement should be of type natural.


The type checker is going to check these rules and will produce an error message when they are violated.

```rascal
include::{LibDir}demo/lang/Pico/Typecheck.rsc[tags=module]
```

                
Notes:

<1>  We will use `TENV` (short for type environment, as an alias for a tuple that contains all relevant type information:
     **  `symbols`: a map from Pico identifiers to their declared type.
     **  `errors`: a list of error messages. An error message is represented by its location (where the error occurred) and a textual message.
<2>  `addError` is an auxiliary function to add in a given type environment an error message to the list of errors. It returns a new type environment.
<3>  `required`is an auxiliarty function to produce readable messages, e.g., `"Required natural, got string"`.
<4>  The actual type checking is done by the functions `checkExp`, `checkStat`, `checkStats`, `checkDecls` and `checkProgram`. They all have three arguments:
     **  the program fragment (an abstract syntax tree) to be checked.
     **  the required type of that fragment.
     **  the type environment.
     
     
     `checkExp` checks expressions. For instance, checking a natural constant (`natCon`) is ok when type `natural` is expected but will give an error message when a `string` is expected. Observe how all the arguments of the check functions have a labeled pattern as first argument, here `exp:natCon(int N)`. The benefit is that the whole argument is available inside the function (as value of variable `exp`) and this can be used to retrieve the location information from it (`exp@location`) when an error has to be created.

<5>  An important case is to check whether an identifier has been defined and, if so, whether it is defined with the expected type.

<6>  Check `add`.

<7>  Check `sub`.

<8> Check `conc`.

<9>  An assignment statement is checked: the identifier on the left-hand side should have been declared and should be type compatible with the expression on the right-hand side.

<10>  Checking if- and while-statements amounts to checking the embedded statements and ensuring that the type of the test is natural.

<11>  Checking a list of statements amounts to checking each statement in the list.

<12>  Checking declarations amounts to extracting each (id, type) pair form the declarations and using a map comprehension to build a type environment.

<13>  Checking a complete Pico program is achieved by first checking the declarations of the program and using the resulting type environment to check its body.

<14>  `checkProgram` defines how to check the source code of a given Pico program.


Checking an erroneous program goes like this:

```rascal-shell
rascal>import demo::lang::Pico::Typecheck;
ok
rascal>checkProgram("begin declare  x : natural; x := \"abc\" end");
lrel[loc l,str msg]: [<|unknown:///|(33,5,<1,33>,<1,38>),"Required natural, got string">]
```

The error location will be use later to give specific messages in the IDE.




## Syntax {#Languages-Pico-Syntax}

### Synopsis 
Concrete syntax for Pico.




### Function 
       



### Examples 
```rascal
include::{LibDir}demo/lang/Pico/Syntax.rsc[tags=module]
```

                
Notes:

*  `Id`, `Natural` and `String` are the basic lexical tokens of the Pico language.
*  `Layout` defines the white space and comments that may occur in a Pico program.
*  Some lexical rules are labeled with `@category="Comment"`. This is for the benefit of syntax highlighting.
*  The start symbol of the Pico grammar is called `Program`.
*  The rules for `Expression` describe the priority and associativity of the operators: all operators are left-associative and `||` has a higher priority then `+` and `-`.
*  Two auxiliary functions `program` are defined that parse a given string or a given location as Pico program.




## ControlFlow {#Languages-Pico-ControlFlow}

### Synopsis 
Compute the control flow graph for a Pico program.



### Function 
       



### Examples 
A control flow graph shows how the entry and exit points of a program are connected with each other via all
decision points and statements in the program. Typically, an assignment statement is a single node in the graph
and an if-then-else statement creates a decision point (its test) that connects the then branch and the else branch.
The exits of each branch are connected to the exit of the if-then-else statement as a whole.

A control flow graph for Pico programs can be created as follows:
```rascal
include::{LibDir}demo/lang/Pico/ControlFlow.rsc[tags=module]
```

                
Notes:

<1> First we define a data type `CFNODE` that represents the various elements of a control flow graph:
    *  `entry`: the entry point of the program.
    *  `exit` the exit point of the program.
    *  `choice`: a decision point in the control flow.
    *  `statement`: a statement in the control flow.

<2> Next we define `CFGRAPH` , an alias for a tuple consisting of the following three elements:
    *  `entry`: the set of entry nodes of the graph.
    *  `graph`: the actual graph of `CFNODE`s.
    *  `exit`: the set of exit nodes.

   The computation of the control flow graph is defined by the functions 
  `cflowStat`, `cflowStats`, `cflowDecls` and `cflowProgram`.

<3> The control flow of an assignment statement is computed by wrapping
    the assignment statement as a `CFNODE` and return a `CFGRAPH` with the assignment
    statement as entry and exit node, and no internal connections.

<4> The control flow of an if-then-else statement is computed as follows:
    *  First the control flows of the then part and the else part are computed,
        yielding `CF1` and `CF2`.
    *  Next a set `E` is created that consist of a the test of the if-then-else statement
        wrapped as choice node.
    *  Finally, a `CFGRAPH` is returned consisting of the followng three elements:
        ***  The entry point set `E`.
        ***  A graph consisting of the connections between the entry point and both
             branches (`E * CF1.entry + E * CF2.entry`) and the internal graphs of both branches
             (`CF1.graph + CF2.graph`).
        ***  The union of exit nodes of both branches (`CF1.exit + CF2.exit`).

<5> The control flow of  while-statement is computed in a similar fashion,
    except that the exit of the loop body has to be connected with the entry
    of the while loop.

<6> The control flow graph for a series of statements is obtained by connecting
    the exits and entries of consecutive statements.

<7> The control flow graph of a complete program is obtained by
    creating an entry and an exit node and connecting them to the graph of
    the statements of the program.

<8> Shows the steps from text to control flow graph.

We can now create a CFG for a small Pico program:

```rascal-shell
rascal>import demo::lang::Pico::ControlFlow;
ok
rascal>cflowProgram("begin declare n : natural, s : string; n := 10; s := \"a\"; while n do s := s + \"a\"; n := n - 1 od end");
tuple[set[CFNode] entry,Graph[CFNode] graph,set[CFNode] exit]: <{entry(|unknown:///|(0,100,<1,0>,<1,100>))},{
<statement(
|unknown:///|(48,8,<1,48>,<1,56>),
asgStat(
"s",
strCon(
"\"a\"",
location=|unknown:///|(53,3,<1,53>,<1,56>),
comments=()),
location=|unknown:///|(48,8,<1,48>,<1,56>),
comments=())),choice(
|unknown:///|(64,1,<1,64>,<1,65>),
id(
"n",
location=|unknown:///|(64,1,<1,64>,<1,65>),
comments=()))>,
<statement(
|unknown:///|(69,12,<1,69>,<1,81>),
asgStat(
"s",
add(
id(
"s",
location=|unknown:///|(74,1,<1,74>,<1,75>),
comments=()),
strCon(
"\"a\"",
location=|unknown:///|(78,3,<1,78>,<1,81>),
comments=()),
location=|unknown:///|(74,7,<1,74>,<1,81>),
comments=()),
location=|unknown:///|(69,12,<1,69>,<1,81>),
comments=())),statement(
|unknown:///|(83,10,<1,83>,<1,93>),
asgStat(
"n",
sub(
id(
"n",
location=|unknown:///|(88,1,<1,88>,<1,89>),
comments=()),
natCon(
1,
location=|unknown:///|(92,1,<1,92>,<1,93>),
comments=()),
location=|unknown:///|(88,5,<1,88>,<1,93>),
comments=()),
location=|unknown:///|(83,10,<1,83>,<1,93>),
comments=()))>,
<statement(
|unknown:///|(39,7,<1,39>,<1,46>),
asgStat(
"n",
natCon(
10,
location=|unknown:///|(44,2,<1,44>,<1,46>),
comments=()),
location=|unknown:///|(39,7,<1,39>,<1,46>),
comments=())),statement(
|unknown:///|(48,8,<1,48>,<1,56>),
asgStat(
"s",
strCon(
"\"a\"",
location=|unknown:///|(53,3,<1,53>,<1,56>),
comments=()),
location=|unknown:///|(48,8,<1,48>,<1,56>),
comments=()))>,
<statement(
|unknown:///|(83,10,<1,83>,<1,93>),
asgStat(
"n",
sub(
id(
"n",
location=|unknown:///|(88,1,<1,88>,<1,89>),
comments=()),
natCon(
1,
location=|unknown:///|(92,1,<1,92>,<1,93>),
comments=()),
location=|unknown:///|(88,5,<1,88>,<1,93>),
comments=()),
location=|unknown:///|(83,10,<1,83>,<1,93>),
comments=())),choice(
|unknown:///|(64,1,<1,64>,<1,65>),
id(
"n",
location=|unknown:///|(64,1,<1,64>,<1,65>),
comments=()))>,
<entry(|unknown:///|(0,100,<1,0>,<1,100>)),statement(
|unknown:///|(39,7,<1,39>,<1,46>),
asgStat(
"n",
natCon(
10,
location=|unknown:///|(44,2,<1,44>,<1,46>),
comments=()),
location=|unknown:///|(39,7,<1,39>,<1,46>),
comments=()))>,
<choice(
|unknown:///|(64,1,<1,64>,<1,65>),
id(
"n",
location=|unknown:///|(64,1,<1,64>,<1,65>),
comments=())),exit()>,
<choice(
|unknown:///|(64,1,<1,64>,<1,65>),
id(
"n",
location=|unknown:///|(64,1,<1,64>,<1,65>),
comments=())),statement(
|unknown:///|(69,12,<1,69>,<1,81>),
asgStat(
"s",
add(
id(
"s",
location=|unknown:///|(74,1,<1,74>,<1,75>),
comments=()),
strCon(
"\"a\"",
location=|unknown:///|(78,3,<1,78>,<1,81>),
comments=()),
location=|unknown:///|(74,7,<1,74>,<1,81>),
comments=()),
location=|unknown:///|(69,12,<1,69>,<1,81>),
comments=()))>
},{exit()}>
```

Is the above not very motivating to move on to [Visualize](#Languages-Pico-Visualize)?




## Lisra {#Languages-Lisra}

### Synopsis 
A lisp interpreter in Rascal.



### Function 
       

### Details 
Syntax Runtime Parse Pretty Eval Test

### Description 

Writing a Lisp interpreter is a classical challenge. 
Popular word has that all large applications evolve until they include a Lisp interpreter.
(A variant says the same about including an email client in every large application).

We will closely follow and *reuse parts of* Peter Norvig's excellent page
on http://norvig.com/lispy.html[Lispy], a Lisp interpreter written in Python.
The Lisp variant to be implemented is the following subset of the http://en.wikipedia.org/wiki/Scheme_(programming_language)[Scheme]
 language:


| Form | Syntax | Semantics and Example |
| --- | --- | --- |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.1[variable reference] |
| _var_ |
| A symbol is interpreted as a variable name; |
  its value is the variable's |
  value. Example: `x` |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2[constant literal] |
| _number_ |
| A number evaluates to itself. Example: `12` |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2[quotation] |
| `(quote exp)` |
| Return the _exp_ literally; do not evaluate it. Example: |
  `(quote (a b c)) =>; (a b c)` |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.5[conditional] |
| `(if _test conseq alt_)` |
| Evaluate _test_; if true, |
  evaluate and return _conseq_; otherwise evaluate and return  |
  _alt_. <br />Example: `(if (< 10 20) (+ 1 1) (+ 3 3)) => 2` |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.6[assignment] |
| `(set! _var exp_)` |
| Evaluate _exp_ and assign that value to |
  _var_, which must have been previously defined (with a |
  `define` or as a parameter to an enclosing procedure). |
   Example: `(set! x2 (* x x))` |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%_sec_5.2[definition] |
| `(define var exp)` |
| Define a new variable in the innermost environment and give it |
  the value of evaluating the expression _exp_.  |
  Examples: `(define r 3)` or `(define square (lambda (x) (* x x)))` |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.4[procedure] |
| `(lambda (_var..._) exp)` |
| Create a procedure |
  with parameter(s) named _var..._ and the expression as the body. |
  Example: `(lambda (r) (* r r))` |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.2.3[sequencing] |
| `(begin _exp..._)` |
| Evaluate each of the expressions in left-to-right order, and return the final value. |
  Example: `(begin (set! x 1) (set! x (+ x 1)) (* x 2)) => 4 |
| http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.3[procedure call] |
| `(_proc exp..._)` |
| If _proc_ is |
   anything other than one of the symbols `if`, `set!`, `define`, |
   `lambda`, `begin`, or `quote` then it is treated as a procedure.  It is |
   evaluated using the same rules defined here. All the expressions |
   are evaluated as well, and then the procedure is called with the list |
   of expressions as arguments.  |
   Example: <`(square 12) => 144 |


In this table, _var_ must be a symbol--an identifier such as x or square--and number must be an integer number, 
while the other italicized words can be any expression. The notation _exp_... means zero or more repetitions of _exp_.

A Lisp interpreter consists of the following parts:

*  A _parser_ that reads a Lisp program in text form and converts it to a runtime representation that is suitable for the interpreter.
*  The _interpreter_ itself that executes the program in runtime representation and computes its outcome.
*  A _pretty printer_ that converts the outcome in internal representation back to text.
*  Finally, an interactive  _console_ is needed that interact with the user.


We discuss all these aspects:

* [Test](#Languages-Lisra-Test)
* [Parse](#Languages-Lisra-Parse)
* [Runtime](#Languages-Lisra-Runtime)
* [Pretty](#Languages-Lisra-Pretty)
* [Eval](#Languages-Lisra-Eval)
* [Syntax](#Languages-Lisra-Syntax)





## Test {#Languages-Lisra-Test}

### Synopsis 
Tests for the Lisp interpreter.



### Function 
       


### Description 

It is good practice to write tests for your software.

Here are our tests for Lisra:

```rascal
include::{LibDir}demo/lang/Lisra/Test.rsc[tags=module]
```

                




## Parse {#Languages-Lisra-Parse}

### Synopsis 
Parsing a Lisp expression.



### Function 
       


### Description 

Given the Lisp [Syntax](#Languages-Lisra-Syntax), we can now apply it to parse textual Lisp expressions
and convert them to the runtime representation `Lval`.

```rascal
include::{LibDir}demo/lang/Lisra/Parse.rsc[tags=module]
```

                
<1> First we define the actual `parse` function: it takes a string as argument and returns an `Lval`.
   It proceeds in two steps:
   **  First the text is parsed using `parse(#LispExp, txt)`. The result is parse tree.
   **  Next, the auxiliary function `build` is used to transform the parse tree to an `Lval`.

<2> Function `build` is defined in cases, to handle the various parse tree forms.
    Fortunately, we do not have to spell out the details of the parse tree, but we can use concrete
    patterns instead (see _Concrete Patterns (broken link)_, below).
 
   The right-hand sides deserve some attention. Here the argument `il` is a _parse tree_ (!!) that represents an integer literal.
   We first convert it to a string using string interpolation (`"<il>"`) and then convert it to an integer.

<3> The text of the atom is reconstructed in a similar fashion.

<4> The concrete list elements in `lst` are converted one-by-one using build and are then used to
    create a new `List` value.

### Concrete  Patterns
****
We use concrete patterns in these definitions. For instance, the argument pattern 
```rascal
(LispExp)`<IntegerLiteral il>`
```
says:

*  Match something of type `LispExp`.
*  It should be an `IntegerLiteral` and bind it to a variable `il`.

More precisely, the text between backquotes should be a string that can be parsed according to the non-terminal
that precedes it (`LispExp` in this example). This is illustrated by the list case where the parentheses appear in the concrete pattern:
```rascal
(LispExp)`( <LispExp* lst> )`
```
****

### Examples 

```rascal-shell
rascal>import demo::lang::Lisra::Parse;
ok
rascal>import demo::lang::Lisra::Runtime;
ok
rascal>parse("1");
Lval: Integer(1)
rascal>parse("x");
Lval: Atom("x")
rascal>parse("(+ 5 7)");
Lval: List([
Atom("+"),
Integer(5),
Integer(7)
])
```




## Runtime {#Languages-Lisra-Runtime}

### Synopsis 
The runtime representation of Lisp programs and data.



### Function 
       


### Description 
There are several aspects of the runtime representation of Lisp programs and Lisp data
that have to be described:

*  The representation of values (see `Lval` below).
*  The handling of the _scope_ of variables (see `Scope`, `Env`, `makeEnv` and `find` below).
*  The way the interpreter returns its results (see `Result` below).


```rascal
include::{LibDir}demo/lang/Lisra/Runtime.rsc[tags=module]
```

                
<1> The data type `Lval` takes care of the representation of Lisp values.
    It covers integers, atoms, lists and closures (the representation of a functions and
    the context in which it will be executed).

<2> A `Scope` describes the binding of several related variables to their value.
    Since scopes may be nested, an environment (`Env`) consisted of a list of scope.
   The most inner scope is at the start of the list and the most global one at the end.

<3> Creating a new scope is done by `makeEnv` which takes a list of variables
    (represented by `Lval`s, in most cases this will be an atom like `Atom("X")`),
    a list of values and creates a new scope in front of the current environment.

<4> The function `find` tries to locate the scope in which a name was previously defined.
    It searches the nested scopes inside-out and returns the _index_ in the given environment
   of the scope in which the name is defined, or `-1` if it is not found.

<5> We define useful constants for true and false (the atoms `#t` and `#f`, respectively).

<6> Finally, we define `Result` as a tuple of an `Lval` and an `Env`.
    Each step during interpretation will thus return the value it computed and
    a possibly modified environment.





## Pretty {#Languages-Lisra-Pretty}

### Synopsis 
A Lisp pretty printer.



### Function 
       


### Description 
The purpose of a pretty printer is to convert an internal structure to text.
We define here the simplest possible solution:

```rascal
include::{LibDir}demo/lang/Lisra/Pretty.rsc[tags=module]
```

                
Compare the definition of `pretty` with that of `parse`:
```rascal
Lval parse(str txt);
str pretty(Lval x);
```

For a well-designed pair of `parse`/`pretty` functions, the latter is the inverse of the former.
In other words, for every `L` the following should hold:
```rascal
parse(pretty(L)) == L
```

### Examples 


```rascal-shell
rascal>import demo::lang::Lisra::Runtime;
ok
rascal>import demo::lang::Lisra::Pretty;
ok
rascal>pretty(Integer(42));
str: "42"
rascal>pretty(Atom("x"));
str: "x"
rascal>L = List([Atom("+"), Integer(5), Integer(7)]);
Lval: List([
Atom("+"),
Integer(5),
Integer(7)
])
rascal>pretty(L);
str: "( + 5 7 )"
```
Now let's explore whether `pretty` is indeed the inverse of `parse`:

```rascal-shell
rascal>import demo::lang::Lisra::Parse;
ok
rascal>parse(pretty(L)) == L;
bool: true
```




## Eval {#Languages-Lisra-Eval}

### Synopsis 
A Lisp interpreter.



### Function 
       


### Description 

Here is the core of our Lisp interpreter. Its basic functionality is to take

*  An `Lval` and an Environment (both defined in [Runtime](#Languages-Lisra-Runtime)).
*  Distinguish the various forms an `Lval` can have and compute the
  effect of evaluating it.
*  Return a `Result` that captures the value just computed and possibleside-effects
on the environment.


Rascal provides pattern-directed dispatch: a function with the same name
can have complete patterns as arguments. When called, a pattern match determines which
variant of the function will be called. This is used extensively in the definitions below:

```rascal
include::{LibDir}demo/lang/Lisra/Eval.rsc[tags=module]
```

                
We now explain the different cases in more detail:

<1> An integer constant evaluates to itself. Note how `Integer(int x)` is used as first
    argument of this `eval` function. It is a pattern that describes that the constructor `Integer`
    with an `int` argument `x` is to be matched.
<2> An atom evaluates to the value to which it is bound or to itself. `find` (see [Runtime]) is used
    to search for the atom in question. The first argument is `var:Atom(str name)`, a pattern that matches
    an `Atom`. The `var:` prefix binds the complete atom to a variable `var` to be used in the body of the function.
<3> A quoted list evaluates to itself. The pattern `List([Atom("quote"), exp*])` matches a `List` constructor
    whose first element is `Atom("quote")`. `exp*` means that the remaining list elements are assignment to `exp`.
    There are two cases: if the argument list has size 1, its first element is used, otherwise a list with all elements of `exp`
    vare returned. This ensures that `List([Atom("quote"), Integer(17)])` evaluates to  `Integer(17)` and not to `List([ Integer(17)]`.
<4> Evaluates a `set!` expression that assigns the value of `exp` to variable `var`.

<5> Evaluates the `if` expression. The test `tst` is evaluated and is not false, the value of `conseq` is returned and otherwise
    that of `alt`.

<6> Evaluates a `block` expression. The list of expressions `exps` is evaluated one by one. Observe that in the for loop
    `<val, e> = eval(exp, e);` captures both the value and the environment that results from executing one expression. That new environment is
    is used to evaluate the next expression(s) in the list. The value of the last expression and a possible modied environment are returned.

<7> Evaluate a `define` expression that binds the value of `exp` to variable `var`.
    The value of the expression is bound `var` in the local scope.

<8> Evaluate a lambda expression. Essentially we return a `Closure` value that contains the expression in the lambda expression
    properly wrapped to do variable binding and environment management. 
    A Closure contains a function that return type `Results` and has two arguments:
   `list[lval] args` the actual parameter values when the closure is applied, and
   `Env e` the environment at the site of the call.
    In the body of the closure we construct a new environment `makeEnv(vars, args, tail(callEnv, size(defEnv)))` that binds the variables
    in the lambda expression to the actual parameter values. What is special here is that we shorten the calling environment to the
    same length as the defining environment. This implements _lexical scoping_ and avoids that names are visible in the called
    function that were not visible when the function was defined. Remember that Rascal values are immutable, meaning that after a value was 
    created it cannot be changed. Using the above trick, we ensure that the called function has access to the most recent version of
    its environment.

<9> Evaluates an arbitrary list. As a special case, the empty list is returned as false.
    Otherwise, all elements are evaluated and the auxiliary function ` apply` is used to apply the value of the first element to the values of   
    the remaining elements.

<10> Apply an `Lval` to a list of arguments and return a `Result`. The first case handles a `Closure`; it amounts
     to calling the function in the closure (environment handling and parameter binding are done in the closure as discussed above.

<11> Definition of all built-in functions.

<12> A default function that prints an error message when an undefined function is called.

### Examples 


```rascal-shell
rascal>import demo::lang::Lisra::Runtime;
ok
rascal>import demo::lang::Lisra::Eval;
ok
rascal>eval(Integer(5));
Lval: Integer(5)
rascal>eval(Atom("x"));
Lval: Atom("x")
rascal>eval(List([Atom("+"), Integer(5), Integer(7)]));
Lval: Integer(12)
```

### Benefits 

*  A very modular, rule-based, type safe Lisp interpreter.

### Pitfalls 

*  It is no pleasure to type in `Lval`s directly, that is why a parser is needed, see [Parse](#Languages-Lisra-Parse).


## Syntax {#Languages-Lisra-Syntax}

### Synopsis 
The textual syntax of Lisp.



### Function 
       


### Description 

The first step in defining Lisp's textual format, we define a grammar for it:

```rascal
include::{LibDir}demo/lang/Lisra/Syntax.rsc[tags=module]
```

                
`Whitespace` defines the characters that can be ignored between tokens.

`IntegerLiteral` defines integer constants. In a first approximation `[0-9]` is enough.
However, to ensure that the longest possible sequence of digits is used, the `!>> [0-9]` part
ensures that an integer cannot be followed by another digit.

`AtomExp` defines a Lisp symbol that may contain a wide range of characters (except layout and digits).

The main syntactic concept is a `LispExp` that may be an `IntegerLiteral`, `AtomExp` or a list
of `LispExp`s surrouned by parentheses.

### Examples 

This grammar is demonstrated in [Parse](#Languages-Lisra-Parse).




## Exp {#Languages-Exp}

### Synopsis 
The _hello world_ of syntax definition and language definition.
It illustrates how to define concrete and abstract syntax and how to use concrete and abstract patterns to evaluate expressions.





### Description 
Our sample language Exp contains the following elements:

*  Integer constants, e.g., `123`.
*  A multiplication operator, e.g., `3*4`.
*  An addition operator, e.g., `3+4`.
*  Multiplication is left-associative and has precedence over addition.
*  Addition is left-associative.
*  Parentheses can be used to override the precedence of the operators.

### Examples 

*  `123`
*  `2+3+4`
*  `2+3*4`
*  `(2+3)*4`




## Abstract {#Languages-Exp-Abstract}

### Synopsis 
A version of Exp based on abstract syntax.





### Description 
The http://en.wikipedia.org/wiki/Abstract_syntax[abstract syntax] for a language is a
data type that is used to represent programs in the language in an _abstract_ form.
Abstract syntax has the following properties:

*  It is "abstract" in the sense that it does not contain textual details such as parentheses,
  layout, and the like.
*  While a language has one grammar (also known as, _concrete syntax_) it may have several abstract syntaxes
  for different purposes: type analysis, code generation, etc.

### Examples 
The abstract syntax for Exp looks like this:
```rascal
include::{LibDir}demo/lang/Exp/Abstract/Syntax.rsc[tags=module]
```

                
<1> Defines integer constants, e.g., `con(123)`.
<2> Defines multiplication, e.g., `mul(con(2),con(3))`.
<3> Defines addition, e.g., `add(con(2),con(3))`.


Given the abstract syntax for Exp, we can define an interpreter that evaluates
expressions:
```rascal
include::{LibDir}demo/lang/Exp/Abstract/Eval.rsc[tags=module]
```

           
Here we see Rascal's _pattern-directed invocation_ in action (see [Function Declaration]_broken:Rascal:Declarations-Function (ambiguous link)_).
The essence is this: in other languages the formal parameters in a function declaration
are just that: formal parameters, i.e., single names that can be used inside the function and
that are bound when the function is called.
In Rascal, however, the formal parameters are actually a _pattern_ and functions
can have arbitrarily complex patterns as (single) formal parameter.
These patterns may bind variables and thus introduce variables that can be used in tthe function body.

The big advantage of pattern-directed invocation is modularity and extensibility:

*  The treatment of the cases in the abstract syntax is decoupled.
*  If the abstract is extended later on with new cases, the functions for the old cases can be reused.


In this example we use this mechanism to define separate functions for each case in the abstract syntax.

<1> Defines the case for evaluating integer constants: they evaluate to themselves.
<2> Defines the case for evaluating multiplication: first evaluate the arguments `e1` and `e2`
    and return the multiplication of their values.
<3> Defines the case for evaluating addition: first evaluate the arguments `e1` and `e2`
    and return the addition of their values.



```rascal-shell
rascal>import demo::lang::Exp::Abstract::Syntax;
ok
rascal>import demo::lang::Exp::Abstract::Eval;
ok
rascal>eval(mul(con(7), con(3)));
int: 21
rascal>eval(add(con(3), mul(con(4), con(5))));
int: 23
```
Entering expressions in abstract syntax form is no fun, and this is where concrete syntax comes to the rescue.





## Concrete {#Languages-Exp-Concrete}

### Synopsis 
Various versions of Exp based on concrete syntax.





### Description 

We discuss several versions of Exp based on concrete syntax:

*  [No Layout](#Languages-Exp-Concrete-NoLayout): is the simplest version that does not consider layout symbols in expressions.
*  [With Layout](#Languages-Exp-Concrete-WithLayout): adds layout information to Exp's synax definition.






## No Layout {#Languages-Exp-Concrete-NoLayout}

### Synopsis 
A version of Exp based on concrete syntax.





### Description 
We describe howto write a grammar for Exp and how to use it to implement an evaluator.


### Examples 
Here is the grammar for Exp:
```rascal
include::{LibDir}demo/lang/Exp/Concrete/NoLayout/Syntax.rsc[tags=module]
```

Notes:

<1> Defines a lexical syntax rule for IntegerLiterals; they consist of one or more digits.
<2> Defines the alternatives for Exp. The keyword `start` means that this is a start symbol of the grammar.
<3> Defines alternative #1: an `IntegerLiteral`.
<4> Defines alternative #2: parentheses. The `|` says that this alternative has the same priority as the previous one.
    The keyword `bracket` marks this as an alternative that defines parentheses.
<5> Defines alternative #3: multiplication. The `>` says that the previous rule has a higher priority than the current one.
    The keyword `left` marks this as a left-associative rule.
<6> Defines alternative #4: addition. The `>` says again that the previous rule has a higher priority than the current one.
    The keyword `left` marks this as a left-associative rule.


Now that the grammar is in place we want to use it to build an evaluator. Here is how:
```rascal
include::{LibDir}demo/lang/Exp/Concrete/NoLayout/Eval.rsc[tags=module]
```

Notes:

<1> We import [Rascal:ParseTree] because we will need the `parse` function below.
<2> The main function `eval` that evaluates an expression as string to an integer. It proceeds in two steps:
    *  `parse(#Exp, txt)` parses the given `txt` according to non-terminal `Exp` as defined by the grammar.
        The result is a parse tree.
    *  This parse tree is given to another eval function that will reduce the tree to an integer.
<3> Converts an IntegerLiteral to an integer. Let's dissect this further:
    *  The `Exp` preceding the concrete pattern, unambiguously defines the type of the pattern.
        This is good practice to avoid ambiguities.
    *  `<IntegerLiteral l>` matches an IntegerLiteral and binds it (a parse tree fragment) to variable `l`.
    *  In the function body, `toInt("<l>")`, the parse tree fragment is inserted in a string -- effectively unparsing it --
        and that string is converted to an integer.
<4> Handle the multiplication case.
<5> Handle the addition case.
<6> Handles the case of parentheses.


What remains, is to check that `eval` works as expected.

```rascal-shell
rascal>import demo::lang::Exp::Concrete::NoLayout::Syntax;
ok
rascal>import ParseTree;
ok
```
Just checking that `parse` returns a sort of parse tree:

```rascal-shell
rascal>parse(#Exp, "2+3");
Exp: (Exp) `2+3`
```
You will see such parse trees only once, unless you are a researcher in parsing ;-)
Here is a demonstration of `eval`:

```rascal-shell
rascal>import demo::lang::Exp::Concrete::NoLayout::Eval;
ok
rascal>eval("2+3");
int: 5
rascal>eval("2+3*4");
int: 14
rascal>eval("(2+3)*4");
int: 20
```





## With Layout {#Languages-Exp-Concrete-WithLayout}

### Synopsis 
Defines a concrete syntax for Exp with layout.





### Description 

In Rascal, the major difference between lexical syntax and non-lexical syntax is that:

* Strings that are parsed according to the lexical syntax __do not__ contain additional layout characters
  such as spaces, new lines, and source code comments.
* Strings that are parsed according to the normal (non-lexical) syntax __can__ contain layout characters between
  each element. 
* Which 'layout' (whitespace and/or source code comments) will be accepted has to be defined explicitly by the grammar writer.


The following example extends the grammar for `Exp` in [No Layout](#Languages-Exp-Concrete-NoLayout) with a layout definition:
```rascal
include::{LibDir}demo/lang/Exp/Concrete/WithLayout/Syntax.rsc[tags=module]
```

<1> Using the `layout` definition, we define that the `Whitespace` non-terminal is used _in between every symbol_ of the `syntax` productions in the current module.

And now we can use spaces in our definition of the eval function as well:
```rascal
include::{LibDir}demo/lang/Exp/Concrete/WithLayout/Eval.rsc[tags=module]
```

Note that [Pattern Matching]_Rascal:Concepts-PatternMatching (broken link)_ will _ignore_ all trees in layout positions, such that the parse tree of "1 + \\n1" will match against `<Exp e1> + <Exp e2>`. The same goes for equality on parse trees.

For the above example Rascal will insert the `Whitespace` non-terminal between every element of the syntax rules for `Exp`.
Moreover, for the start production (See [No Layout](#Languages-Exp-Concrete-NoLayout)) `Whitespace` will be added before and after the `Exp`.

### Examples 

The effect of the layout definition is that before parser generation the following grammar is derived for `Exp`:
```rascal
syntax Exp 
  = IntegerLiteral          
  | bracket "(" Whitespace Exp Whitespace ")"     
  > left Exp Whitespace "*" Whitespace Exp        
  > left Exp Whitespace "+" Whitespace Exp        
  ;

syntax start[Exp] = Whitespace Exp top Whitespace;
```

To put this all to the test:

```rascal-shell
rascal>import demo::lang::Exp::Concrete::WithLayout::Syntax;
ok
rascal>import demo::lang::Exp::Concrete::WithLayout::Eval;
ok
rascal>eval("2 +  3");
int: 5
rascal>eval("2   +  3*4");
int: 14
rascal>eval("( 2+3 )* 4");
int: 20
```


### Pitfalls 

*  If the grammar for `Exp` would contain an optional symbol, as in `syntax Exp = Exp "+"? Exp`, then it would be ambiguous. Does a space in "1 1", belong to the `Whitespace` before or after the missing `+`? To disambiguate the `layout` definition should be changed to `layout Whitespace = [\ \t\n\r]* !>> [\ \t\n\r]`. That will make sure the space goes with the first Whitespace, because even an empty Whitespace list must never be followed immediately by a space.


## Combined {#Languages-Exp-Combined}

### Synopsis 
Combine concrete syntax with abstract syntax.





### Description 
Concrete syntax gives full control over the textual appearance of a language and leads to parse trees
in a standard format (i.e., values of type `Tree`).

Abstract syntax can be designed by the Rascal programmer according to his/her needs regarding
the type checking, code generation, transformation, or optimization to be done on the abstract syntax trees.

How can we bridge this gap? We discuss two approaches:

*  [Manual](#Languages-Exp-Combined-Manual): a transformation is written manually to convert parse trees to abstract syntax trees.
*  [Automatic](#Languages-Exp-Combined-Automatic): the library function [Rascal:implode] is used to automate this transformation.






## Automatic {#Languages-Exp-Combined-Automatic}

### Synopsis 
Use implode to translate an Exp parse tree to an abstract syntax tree.





### Description 

[implode]_Libraries:ParseTree-implode (broken link)_ is a function that automates the mapping between parse trees and abstract syntax trees.
It takes two arguments:

*  The _reified_ type of the desired abstract syntax. (In Rascal, types can not be used freely as values.
  A reified type, is a type that is wrapped in such a way that it can be passed as an argument to a function.)
*  The parse tree to be converted.


`implode` is smart in trying to find a mapping, but it needs some guidance.
A necessary step is therefore to label the rules in the grammar with the name of the 
constructor to which it has to be mapped.

### Examples 
Let's first label the syntax rules of the Exp grammar with constructor names:
```rascal
include::{LibDir}demo/lang/Exp/Combined/Automatic/Syntax.rsc[tags=module]
```
            
Observe that at image:{images}/1.png[], image:{images}/2.png[] and image:{images}/3.png[] these labels have been added.

It is good practice to introduce separate modules for parsing and for the conversion itself:

*  A `Parse` module defines a parse function and returns a parse tree. It imports only the concrete syntax.
*  A `Load` module defines a load function that first calls the above `parse` function and then applies `implode` to it.
  This is the only module that imports both concrete and abstract syntax at the same time and is therefore the only place to be
  concerned about name clashes. (If I mention `Exp`, do you know which one I mean?).


Here is the `Parse` module for Exp ...
```rascal
include::{LibDir}demo/lang/Exp/Combined/Automatic/Parse.rsc[tags=module]
```

and this is how it works:

```rascal-shell
rascal>import demo::lang::Exp::Combined::Automatic::Parse;
ok
rascal>parseExp("2+3*4");
Tree: appl(
prod(
label(
"add",
sort("Exp")),
[
sort("Exp"),
layouts("LAYOUTLIST"),
lit("+"),
layouts("LAYOUTLIST"),
sort("Exp")
],
{assoc(left())}),
[appl(
prod(
label(
"con",
sort("Exp")),
[lex("IntegerLiteral")],
{}),
[appl(
prod(
lex("IntegerLiteral"),
[iter(\char-class([range(48,57)]))],
{}),
[appl(
regular(iter(\char-class([range(48,57)]))),
[char(50)],
src=|unknown:///|(0,1,<1,0>,<1,1>))],
src=|unknown:///|(0,1,<1,0>,<1,1>))],
src=|unknown:///|(0,1,<1,0>,<1,1>)),appl(
prod(
layouts("LAYOUTLIST"),
[conditional(
\iter-star(lex("LAYOUT")),
{\not-follow(\char-class([
range(9,10),
range(13,13),
range(32,32)
]))})],
{}),
[appl(
regular(\iter-star(lex("LAYOUT"))),
[],
src=|unknown:///|(1,0,<1,1>,<1,1>))],
src=|unknown:///|(1,0,<1,1>,<1,1>)),appl(
prod(
lit("+"),
[\char-class([range(43,43)])],
{}),
[char(43)]),appl(
prod(
layouts("LAYOUTLIST"),
[conditional(
\iter-star(lex("LAYOUT")),
{\not-follow(\char-class([
range(9,10),
range(13,13),
range(32,32)
]))})],
{}),
[appl(
regular(\iter-star(lex("LAYOUT"))),
[],
src=|unknown:///|(2,0,<1,2>,<1,2>))],
src=|unknown:///|(2,0,<1,2>,<1,2>)),appl(
prod(
label(
"mul",
sort("Exp")),
[
sort("Exp"),
layouts("LAYOUTLIST"),
lit("*"),
layouts("LAYOUTLIST"),
sort("Exp")
],
{assoc(left())}),
[appl(
prod(
label(
"con",
sort("Exp")),
[lex("IntegerLiteral")],
{}),
[appl(
prod(
lex("IntegerLiteral"),
[iter(\char-class([range(48,57)]))],
{}),
[appl(
regular(iter(\char-class([range(48,57)]))),
[char(51)],
src=|unknown:///|(2,1,<1,2>,<1,3>))],
src=|unknown:///|(2,1,<1,2>,<1,3>))],
src=|unknown:///|(2,1,<1,2>,<1,3>)),appl(
prod(
layouts("LAYOUTLIST"),
[conditional(
\iter-star(lex("LAYOUT")),
{\not-follow(\char-class([
range(9,10),
range(13,13),
range(32,32)
]))})],
{}),
[appl(
regular(\iter-star(lex("LAYOUT"))),
[],
src=|unknown:///|(3,0,<1,3>,<1,3>))],
src=|unknown:///|(3,0,<1,3>,<1,3>)),appl(
prod(
lit("*"),
[\char-class([range(42,42)])],
{}),
[char(42)]),appl(
prod(
layouts("LAYOUTLIST"),
[conditional(
\iter-star(lex("LAYOUT")),
{\not-follow(\char-class([
range(9,10),
range(13,13),
range(32,32)
]))})],
{}),
[appl(
regular(\iter-star(lex("LAYOUT"))),
[],
src=|unknown:///|(4,0,<1,4>,<1,4>))],
src=|unknown:///|(4,0,<1,4>,<1,4>)),appl(
prod(
label(
"con",
sort("Exp")),
[lex("IntegerLiteral")],
{}),
[appl(
prod(
lex("IntegerLiteral"),
[iter(\char-class([range(48,57)]))],
{}),
[appl(
...
```

We can use `parse` to define `load`:
```rascal
include::{LibDir}demo/lang/Exp/Combined/Automatic/Load.rsc[tags=module]
```

Notes:

<1> We also need the `parse` function, as defined above.
<2> We also need the abstract syntax as already defined earlier in [Exp/Abstract].
<3> We need [Rascal:ParseTree] since it provides the [Rascal:implode] function.


Let's try it:

```rascal-shell
rascal>import demo::lang::Exp::Combined::Automatic::Load;
ok
rascal>load("2+3*4");
Exp: add(
con(
2,
location=|unknown:///|(0,1,<1,0>,<1,1>),
comments=()),
mul(
con(
3,
location=|unknown:///|(2,1,<1,2>,<1,3>),
comments=()),
con(
4,
location=|unknown:///|(4,1,<1,4>,<1,5>),
comments=()),
location=|unknown:///|(2,3,<1,2>,<1,5>),
comments=()),
location=|unknown:///|(0,5,<1,0>,<1,5>),
comments=())
```

Remains the definition of the `eval` function:
```rascal
include::{LibDir}demo/lang/Exp/Combined/Automatic/Eval.rsc[tags=module]
```

                
Here is the end result:

```rascal-shell
rascal>import demo::lang::Exp::Combined::Automatic::Eval;
ok
rascal>eval("2+3*4");
int: 14
```




## Manual {#Languages-Exp-Combined-Manual}

### Synopsis 
An Exp evaluator that uses a manually written conversion from parse tree to abstract syntax tree.






### Examples 

First we define a `parse` function for Exp:

```rascal
include::{LibDir}demo/lang/Exp/Combined/Manual/Parse.rsc[tags=module]
```

and test it:

```rascal-shell
rascal>import demo::lang::Exp::Combined::Manual::Parse;
ok
rascal>parseExp("2+3");
Exp: (Exp) `2+3`
```

Next, we define a `load` function:
```rascal
include::{LibDir}demo/lang/Exp/Combined/Manual/Load.rsc[tags=module]
```

Some comments:

<1> We reuse the previously defined concrete syntax with layout.
<2> We also reuse the previously defined abstract syntax.
<3> Import the `Parse` module defined above.
<4> The top level `load` function that converts a string to an abstract syntax tree.
<5> The conversion from parse tree to abstract syntax tree start here. Note that we
    explicitly use `demo::lang::Exp::Abstract::Syntax::Exp` in these
    rules to distinguish from `demo::lang::Exp::Concrete::WithLayout::Syntax::Exp`.


Let's try it:

```rascal-shell
rascal>import demo::lang::Exp::Combined::Manual::Load;
ok
rascal>loadExp("2+3");
Exp: add(
con(2),
con(3))
```


What remains is to write the interpreter using the above components:
```rascal
include::{LibDir}demo/lang/Exp/Combined/Manual/Eval.rsc[tags=module]
```

                
Here is how it works:

```rascal-shell
rascal>import demo::lang::Exp::Combined::Manual::Eval;
ok
rascal>eval("2+3");
int: 5
```




## Func {#Languages-Func}

### Synopsis 
Func is a tiny functional language; we present several interpreters for it.





### Description 
Func is a functional language with the following features:

* A program consists of a number of function declarations.
* A function declaration consists of a name, zero or more formal parameter names and an expression.
* An expression can be one of:
  **  an integer constant.
  **  a variable.
  **  arithmetic operators `+`, `-`, `*` and `/`.
  **  comparison operators `<`, `\<=`, `>` and `>=`.
  **  a call of a function.
  **  an `if` expression.
  **  a sequence of expressions (`;`).
  **  an assignment (`:=`).
  **  a `let` expression to introduce new bindings for local variables.
  **  an address of a variables (denoted by `&`).
  **  derefence of a variable (denoted by `*`).


Some features add more complexity to an interpreter, therefore
we present four interpreters [Eval0](#Languages-Func-Eval0), [Eval1](#Languages-Func-Eval1), [Eval2](#Languages-Func-Eval2) and [Eval2](#Languages-Func-Eval2)
that implement increasingly complex features:


| Feature              | Eval0 | Eval1 | Eval2 | Eval3 |
| --- | --- | --- | --- | --- |
| function declaration | y     | y     | y     | y |
| integer constant     | y     | y     | y     | y |
| variable             | y     | y     | y     | y |
| arithmetic operators | y     | y     | y     | y |
| comparison operators | y     | y     | y     | y |
| call                 | y     | y     | y     | y |
| if                   | y     | y     | y     | y |
| let                  |       | y     | y     | y |
| sequence             |       |       | y     | y |
| assignment           |       |       | y     | y |
| address operator     |       |       |       | y |
| dereference operator |       |       |       | y |


### Examples 
Here are several versions of the factorial function
that use more and more features of the Func language:

`F0.func`:
```rascal
include::{LibDir}demo/lang/Func/programs/F0.func[]
```

`F1.func`:
```rascal
include::{LibDir}demo/lang/Func/programs/F1.func[]
```

`F2.func`:
```rascal
include::{LibDir}demo/lang/Func/programs/F2.func[]
```

`F3.func`:
```rascal
include::{LibDir}demo/lang/Func/programs/F3.func[]
```

                
For convenience, we use two versions of these examples for each _F_:

*  A file _F_`.func` that contains the code as shown above.
*  A file _F_`.rsc` a Rascal file that declares a string variable _F_ with the same content.


For instance, `F0.rsc` looks like this 
```rascal
include::{LibDir}demo/lang/Func/programs/F0.rsc[]
```

NOTE: Note the escaped `<` character in `\\<=`. This is necessary since `<` and `>` are used
in strings to enclose interpolations (insertion of the value of a Rascal expression).
Both symbols need to be escaped when used as literal symbol and not as interpolation.
                



## Eval0 {#Languages-Func-Eval0}

### Synopsis 
A Func interpreter that does not support let-expressions and pointers.





### Description 

Interpreter Eval0 supports the following features of Func:


| Feature              | Eval0 |
| --- | --- |
| function declaration | y |
| integer constant     | y |
| variable             | y |
| arithmetic operators | y |
| comparison operators | y |
| call                 | y |
| if                   | y |
| let                  |
| sequence             |
| assignment           |
| address operator     |
| dereference operator |


### Examples 

Here is the code for Eval0:
```rascal
include::{LibDir}demo/lang/Func/Eval0.rsc[tags=module]
```

Some points to note:

<1> `PEnv` is used as an alias for a map from names to functions. Such maps are used to represent the function definitions in the program.
<2> Here the top level interpreter `eval0` is defined. It takes the name of the main function, a list of actual parameters, and the complete Func program. Binding of variables is done by substitution.
<3> The substitution function is defined. It takes an expression, a list of variables, and a list of integer values to be substituted for them. Note how a [Rascal:Visit] is used to find all the variables in the expression and to replace them.
<4> The versions of `eval0` for each implemented construct. They all have a `PEnv` argument that is needed
    to resolve calls.
<5> The if expression is defined: the then-branch is taken when the test evaluates to a non-zero integer.
<6> The call expression is interpreted. It contains the following steps:
    *  The actual parameters are evaluated.
    *  A substitution is made in the body of the called function, replacing formal parameters by actual values.
    *  The result of this substitution is evaluated.


Let's try this on example `F0`:
```rascal
include::{LibDir}demo/lang/Func/programs/F0.func[]
```

                

```rascal-shell
rascal>import demo::lang::Func::Load;
ok
rascal>import demo::lang::Func::Eval0;
ok
rascal>import demo::lang::Func::programs::F0;
ok
rascal>eval0("fact", [10], load(F0));
value: 3628800
```




## Load AST {#Languages-Func-LoadAST}

### Synopsis 
Parse Func program from string or file and convert to an abstract syntax tree.





### Description 
To simplify later processing, Func programs are converted to an abstract syntax tree.

### Examples 
The concrete syntax for Func is described in [Concrete syntax](#Languages-Func-ConcreteSyntax) and its
abstract syntax in [Abstract syntax](#Languages-Func-AbstractSyntax).
Rather than manually writing conversion rules from Func parse trees to Func abstract syntax trees
we use our secret weapon: [implode]_Libraries:PareTree-implode (broken link)_ that performs the mapping for us.
As you see when you compare the concrete and abstract syntax, the ground work has already been done
by appropriately labelling concrete rules with constructor names of the abstract syntax.

Here is the code for the `load` funcion:

```rascal
include::{LibDir}demo/lang/Func/Load.rsc[tags=module]
```

                
This looks simple but also slightly intimidating due to the many qualified names.
The issue is that the names in the concrete and abstract syntax are (on purpose) overloaded.
A name like `Prog` can be the one from the concrete syntax(i.e., `demo::lang::Func::Func::Prog`)
or the one from the abstract syntax (i.e., `demo::lang::Func::AST::Prog`).

For instance, the local version of `implode` defined here get a concrete `Prog` as argument and returns an abstract one.
Both `load` function return an abstract `Prog`.

Let's try this on example `F0`:
```rascal
include::{LibDir}demo/lang/Func/programs/F0.func[]
```

                

```rascal-shell
rascal>import demo::lang::Func::Load;
ok
rascal>import demo::lang::Func::programs::F0;
ok
rascal>load(F0);
Prog: prog(
[func(
"fact",
["n"],
cond(
leq(
var(
"n",
location=|unknown:///|(13,1,<1,13>,<1,14>),
comments=()),
nat(
1,
location=|unknown:///|(18,1,<1,18>,<1,19>),
comments=()),
location=|unknown:///|(13,6,<1,13>,<1,19>),
comments=()),
nat(
1,
location=|unknown:///|(38,1,<2,13>,<2,14>),
comments=()),
mul(
var(
"n",
location=|unknown:///|(70,1,<4,13>,<4,14>),
comments=()),
call(
"fact",
[sub(
var(
"n",
location=|unknown:///|(79,1,<4,22>,<4,23>),
comments=()),
nat(
1,
location=|unknown:///|(81,1,<4,24>,<4,25>),
comments=()),
location=|unknown:///|(79,3,<4,22>,<4,25>),
comments=())],
location=|unknown:///|(74,9,<4,17>,<4,26>),
comments=()),
location=|unknown:///|(70,13,<4,13>,<4,26>),
comments=()),
location=|unknown:///|(10,87,<1,10>,<5,13>),
comments=()),
location=|unknown:///|(0,97,<1,0>,<5,13>),
comments=())],
location=|unknown:///|(0,97,<1,0>,<5,13>),
comments=())
```
We get the original program and its __abstract syntax tree__ of type `Prog` back.
In case of doubt, compare this with the result in [Parse](#Languages-Func-Parse) where we did obtain a parse tree.
Next, we try the same from a file:

```rascal-shell
rascal>load(|std:///demo/lang/Func/programs/F0.func|);
Prog: prog(
[func(
"fact",
["n"],
cond(
leq(
var(
"n",
location=|std:///demo/lang/Func/programs/F0.func|(13,1,<1,13>,<1,14>),
comments=()),
nat(
1,
location=|std:///demo/lang/Func/programs/F0.func|(18,1,<1,18>,<1,19>),
comments=()),
location=|std:///demo/lang/Func/programs/F0.func|(13,6,<1,13>,<1,19>),
comments=()),
nat(
1,
location=|std:///demo/lang/Func/programs/F0.func|(38,1,<2,13>,<2,14>),
comments=()),
mul(
var(
"n",
location=|std:///demo/lang/Func/programs/F0.func|(70,1,<4,13>,<4,14>),
comments=()),
call(
"fact",
[sub(
var(
"n",
location=|std:///demo/lang/Func/programs/F0.func|(79,1,<4,22>,<4,23>),
comments=()),
nat(
1,
location=|std:///demo/lang/Func/programs/F0.func|(81,1,<4,24>,<4,25>),
comments=()),
location=|std:///demo/lang/Func/programs/F0.func|(79,3,<4,22>,<4,25>),
comments=())],
location=|std:///demo/lang/Func/programs/F0.func|(74,9,<4,17>,<4,26>),
comments=()),
location=|std:///demo/lang/Func/programs/F0.func|(70,13,<4,13>,<4,26>),
comments=()),
location=|std:///demo/lang/Func/programs/F0.func|(10,87,<1,10>,<5,13>),
comments=()),
location=|std:///demo/lang/Func/programs/F0.func|(0,97,<1,0>,<5,13>),
comments=())],
location=|std:///demo/lang/Func/programs/F0.func|(0,97,<1,0>,<5,13>),
comments=())
```




## Concrete Syntax {#Languages-Func-ConcreteSyntax}

### Synopsis 
The concrete syntax of Func.






### Examples 
```rascal
include::{LibDir}demo/lang/Func/Func.rsc[tags=module]
```

                
The concrete syntax of Func uses many features of Rascal's syntax definitions. Some notes:

*   The definition of lexical syntax follows the pattern:
**  Define lexical symbols (`Ident`, `Natural`).
**  Define rules for layout.
**  Use follow restrictions (`!>>`) to enforce the longest match of lexical symbols.
*  The definition of lexical also follows a common pattern:
**  List of non-terminal is defined with their alternatives.
**  One non-terminal is designated as start symbol (`Prog`).
**  Each alternative has a label, this is for the benefit of converting parse trees to abstract syntaxt trees.
**  Each alternative spells out its priority and associativity.




## Eval1 {#Languages-Func-Eval1}

### Synopsis 
Like Eval0 but with support for let-expressions.






### Description 
Interpreter Eval1 supports the following features of Func: 


| Feature              | Eval1 |
| --- | --- |
| function declaration | y |
| integer constant     | y |
| variable             | y |
| arithmetic operators | y |
| comparison operators | y |
| call                 | y |
| if                   | y |
| __let__              | y |
| sequence             |
| assignment           |
| address operator     |
| dereference operator |




In particular, the let construct is supported and this requires the addition
of an extra environment for <name, value> bindings.

### Examples 
```rascal
include::{LibDir}demo/lang/Func/Eval1.rsc[tags=module]
```

                
<1> The alias `Env` is introduced that maps strings to integers.
    All evaluation functions get an extra Env argument.
<2> The environment is used to retrieve a variable's value.
<3> The environment is extended with new bindings.


Let's try this with F1:
```rascal
include::{LibDir}demo/lang/Func/programs/F1.func[]
```

The result:

```rascal-shell
rascal>import demo::lang::Func::Load;
ok
rascal>import demo::lang::Func::Eval1;
ok
rascal>import demo::lang::Func::programs::F1;
ok
rascal>eval1("fact", [10], load(F1));
int: 3628800
```




## Parse {#Languages-Func-Parse}

### Synopsis 
Parse a Func program from a string or a file.





### Description 
Parsing uses the syntax rules for a given start non-terminnal to parse a string and turn it into a parse tree.
The work horse is the [parse]_Libraries:ParseTree-parse (broken link)_ function that is available in the 
[PareTree]_Libraries:Prelude-ParseTree (broken link)_ library.

### Examples 
Here is how to parse Func programs from a string or file:
```rascal
include::{LibDir}demo/lang/Func/Parse.rsc[tags=module]
```

                
Let's try this on example `F0.func`:
```rascal
include::{LibDir}demo/lang/Func/programs/F0.func[]
```

First, we try the version with a string argument:

```rascal-shell
rascal>import demo::lang::Func::Parse;
ok
rascal>import demo::lang::Func::programs::F0;
ok
rascal>parse(F0);
Prog: (Prog) `fact(n) = if n <= 1 then
1
else
n * fact(n-1)
end`
```
This must be defined as success: we get the original program and its parse tree back.
Next, we try the same from a file. We use the scheme `std` that refers to files that reside in the Rascal library.
See [$Rascal:Expressions/Values/Location] for further details on other schemes.

```rascal-shell
rascal>parse(|std:///demo/lang/Func/programs/F0.func|);
Prog: (Prog) `fact(n) = if n <= 1 then
1
else
n * fact(n-1)
end`
```




## Eval3 {#Languages-Func-Eval3}

### Synopsis 
A complete Func interpreter including support for the address and dereference operators.





### Description 

Interpreter Eval3 supports the following features of Func: 


| Feature              | Eval3 |
| --- | --- |
| function declaration | y |
| integer constant     | y |
| variable             | y |
| arithmetic operators | y |
| comparison operators | y |
| call                 | y |
| if                   | y |
| let                  | y |
| sequence             | y |
| assignment           | y |
| __address operator__ | y |
| __dereference operator__ | y |




The main additions are the address and dereference operators.

### Examples 
```rascal
include::{LibDir}demo/lang/Func/Eval3.rsc[tags=module]
```

                

We apply `eval3` to example `F3`:
```rascal
include::{LibDir}demo/lang/Func/programs/F3.func[]
```

                
Let's try this.

```rascal-shell
rascal>import demo::lang::Func::Load;
ok
rascal>import demo::lang::Func::Eval3;
ok
rascal>import demo::lang::Func::programs::F3;
ok
rascal>eval3("fact", [10], load(F3));
tuple[list[int],int]: <[10],3628800>
```






## Eval2 {#Languages-Func-Eval2}

### Synopsis 
Like Eval1 but with support for sequences and assignments.






### Description 
Interpreter Eval2 supports the following features of Func: 


| Feature              | Eval2 |
| --- | --- |
| function declaration | y |
| integer constant     | y |
| variable             | y |
| arithmetic operators | y |
| comparison operators | y |
| call                 | y |
| if                   | y |
| let                  | y |
| __sequence__         | y |
| __assignment__       | y |
| address operator     |
| dereference operator |




The main additions are local side effects and the sequence operator.

### Examples 

```rascal
include::{LibDir}demo/lang/Func/Eval2.rsc[tags=module]
```

                
<1> The alias `Result` is introduced: a pair of an environment and an integer value.
    All evaluator functions are changed from returning an integer (the result of evaluation) to
   `Result` (the result of evaluation _and_ the local side effects).
<2> The effect of this change can be seen in all functions. For instance, when evaluating
    multiplication, the environment produced by the left operand ahs to be passed as 
    argument to the right operand of the multiplication. This is needed, to propagate any side effects
    caused by the left operand to propagate to the right one.
<3> Assignment is implemented.
<4>  Sequencing is implemented. Observe that that the value of the left operand is ignored and that
  the value of the right operand is returned.


We apply `eval2` to example `F2`:
```rascal
include::{LibDir}demo/lang/Func/programs/F2.func[]
```

                
Let's try this.

```rascal-shell
rascal>import demo::lang::Func::Load;
ok
rascal>import demo::lang::Func::Eval2;
ok
rascal>import demo::lang::Func::programs::F2;
ok
rascal>eval2("fact", [10], load(F2));
tuple[map[str, int],int]: <("n":3628800),3628800>
```




## Abstract Syntax {#Languages-Func-AbstractSyntax}

### Synopsis 
The abstract syntax for Func.






### Examples 

Here is the abstract syntax for Func:
```rascal
include::{LibDir}demo/lang/Func/AST.rsc[tags=module]
```

                
Observe that the abstract syntax follows the structure of the [Concrete syntax](#Languages-Func-ConcreteSyntax) but
omits details such as operator priorities, parentheses, and the like.




## Common {#Common-Common}

### Synopsis 
Solutions for some common tasks.





### Description 
We discuss the following tasks:

* _broken:Recipes:Common-Derivative (ambiguous link)_
* _broken:Recipes:Common-CallAnalysis (ambiguous link)_
* _broken:Recipes:Common-WordCount (ambiguous link)_
* _broken:Recipes:Common-WordReplacement (ambiguous link)_
* _broken:Recipes:Common-CallLifting (ambiguous link)_
* _broken:Recipes:Common-ColoredTrees (ambiguous link)_
* _broken:Recipes:Common-StringTemplate (ambiguous link)_
* _broken:Recipes:Common-AdHocDataExploration (ambiguous link)_
* _broken:Recipes:Common-CountConstructors (ambiguous link)_





## Derivative {#Common-Derivative}

### Synopsis 
Symbolic differentiation.





### Description 
Computing the http://en.wikipedia.org/wiki/Differentiation_(mathematics)[derivative] of an expression with respect to some variable is a classical calculus problem. Loosely speaking, a derivative can be thought of as how much one quantity is changing in response to changes in some other quantity; for example, the derivative of the position of a moving object with respect to time is the object's instantaneous velocity.

We present here rules for determining the derivative `dE/dX` of simple expressions `E` for a given variable `X`. Recall that for number `N`, variables `X` and `Y`, and expressions `E1` and `E2` the following rules apply:

*  `dN / dX = 0`.
*  `dX / dX = 1`.
*  `dX / dY = 0`, when `X != Y`.
*  `d(E1 + E2) /dX = dE1 / dX + d E2 /dX`.
*  `d(E1 * E2) / dX =  (d E1 / dX  * E2) + (E1 * d E2 /dX)`.


### Examples 

Here is our solution followed by a list of explanations:

```rascal
include::{LibDir}demo/common/Derivative.rsc[tags=module]
```

<1> Define a data type `Exp` to represent expressions.
<2> Introduce an example expression `E` for later use.
<3> Define the actual differentiation function `dd`. Observe that this definition depends on the use of patterns in function declarations, see [Rascal:Function].
<4> Define simplification rules. 
<5> A default rule is give for the case that no simplification applies.
<6> Define the actual simplication function `simplify` that performs a bottom up traversal of the expression, application simplification
rules on the up.

                
Let's differentiate the example expression `E`:

```rascal-shell
rascal>import demo::common::Derivative;
ok
rascal>dd(E, var("x"));
Exp: add(
add(
mul(
con(0),
var("y")),
mul(
con(3),
con(0))),
add(
mul(
con(0),
var("x")),
mul(
con(5),
con(1))))
```
As you can see, we managed to compute a derivative, but the result is far more complex than we would like.
This is where simplification comes in. First try a simple case:

```rascal-shell
rascal>simplify(mul(var("x"), add(con(3), con(5))));
Exp: mul(
var("x"),
con(8))
```
Now apply simplification to the result of differentiation:

```rascal-shell
rascal>simplify(dd(E, var("x")));
Exp: con(5)
```




## Call Analysis {#Common-CallAnalysis}

### Synopsis 
Analyzing the call structure of an application.






### Description 

Suppose a mystery box ends up on your desk. When you open it, it contains a huge software system with several questions attached to it:

*  How many procedure calls occur in this system?
*  How many procedures does it contains?
*  What are the entry points for this system, i.e., procedures that call others but are not called themselves?
*  What are the leaves of this application, i.e., procedures that are called but do not make any calls themselves?
*  Which procedures call each other indirectly?
*  Which procedures are called directly or indirectly from each entry point?
*  Which procedures are called from all entry points?


Let's see how these questions can be answered using Rascal.

### Examples 

Consider the following call graph (a box represents a procedure and an arrow represents a call from one procedure to another procedure):


![]_broken:CallAnalysis-calls.png (ambiguous link)_



```rascal-shell
rascal>import Set;
ok
rascal>import Relation;
ok
rascal>import analysis::graphs::Graph;
ok
```
Rascal supports basic data types like integers and strings which are sufficient to formulate and answer the questions at hand. However, we
can gain readability by introducing separately named types for the items we are describing. 
First, we introduce therefore a new type `Proc` (an alias for strings) to denote procedures:

```rascal-shell
rascal>alias Proc = str;
ok
```
Next, we have to represent the call relation as a Rascal datatype, and the relation is the most appropriate for it.
As preparation, we also import the libraries [$Rascal:Prelude/Set], [$Rascal:Prelude/Relation] and [$Rascal:Libraries/analysis/graphs/Graph] that will come in handy.

```rascal-shell
rascal>rel[Proc, Proc] Calls = {<"a", "b">, <"b", "c">, <"b", "d">, <"d", "c">, 
>>>>>>>                         <"d", "e">, <"f", "e">, <"f", "g">, <"g", "e">};
rel[str,str]: {
<"a","b">,
<"g","e">,
<"b","c">,
<"b","d">,
<"d","c">,
<"d","e">,
<"f","e">,
<"f","g">
}
```
Now we are in a good position to start asking some questions.

__How many calls occur in this system?__
We use the function [Rascal:Set/size] to determine the number of elements in a set or relation.
Since each tuple in the `Calls` relation represents a call between procedures, the number of tuples is equal
to the number of calls.

```rascal-shell
rascal>size(Calls);
int: 8
```
__How many procedures occur in this system?__ This question is more subtle, since a procedure may call (or be called) by
several others and the number of tuples is therefore not indicative. What we need are the set of procedures that
occur (as first or second element) in _any_ tuple. This is precisely what the function [$Rascal:Libraries/Prelude/Relation/carrier] gives us:

```rascal-shell
rascal>carrier(Calls);
set[str]: {"a","b","c","d","e","f","g"}
```
and computing the number of procedures is now easy:

```rascal-shell
rascal>size(carrier(Calls));
int: 7
```
As an aside, functions [$Rascal:Prelude/Relation/domain] and [$Rascal:Prelude/Relation/range] do the same for the first, respectively, second element of the pairs in a relation:

```rascal-shell
rascal>domain(Calls);
set[str]: {"a","b","d","f","g"}
rascal>range(Calls);
set[str]: {"b","c","d","e","g"}
```
__What are the entry points for this system?__

The next step in the analysis is to determine which entry points this application has, i.e., procedures which call others but are 
not called themselves. Entry points are useful since they define the external interface of a system and may also be used as guidance to
split a system in parts. The top of a relation contains those left-hand sides of tuples in a relation that do not occur in any 
right-hand side. When a relation is viewed as a graph, its top corresponds to the root nodes of that graph. Similarly, the bottom of a 
relation corresponds to the leaf nodes of the graph. See the section called  [$Rascal:Libraries/analysis/graphs/Graph] for more details. Using this knowledge, the entry
points can be computed by determining the top of the Calls relation:

```rascal-shell
rascal>top(Calls);
set[str]: {"a","f"}
```
__What are the leaves of this application?__

In a similar spirit, we can determine the leaves of this application, i.e., procedures that are being called but do not make any calls
themselves:

```rascal-shell
rascal>bottom(Calls);
set[str]: {"c","e"}
```
__Which procedures call each other indirectly?__

We can also determine the indirect calls between procedures, by taking the transitive closure of the Calls relation, written as `Calls+`. 
Observe that the transitive closure will contain both the direct and the indirect calls.

```rascal-shell
rascal>closureCalls = Calls+;
rel[str,str]: {
<"g","e">,
<"a","b">,
<"a","c">,
<"a","d">,
<"a","e">,
<"b","c">,
<"b","d">,
<"b","e">,
<"d","c">,
<"d","e">,
<"f","e">,
<"f","g">
}
```
__Which procedures are called directly or indirectly from each entry point?__

We now know the entry points for this application ("a" and "f") and the indirect call relations. Combining this information, 
we can determine which procedures are called from each entry point. This is done by indexing closureCalls with appropriate procedure name.
The index operator yields all right-hand sides of tuples that have a given value as left-hand side. This gives the following:

```rascal-shell
rascal>calledFromA = closureCalls["a"];
set[str]: {"b","c","d","e"}
rascal>calledFromF = closureCalls["f"];
set[str]: {"e","g"}
```
__Which procedures are called from all entry points?__

Finally, we can determine which procedures are called from both entry points by taking the intersection of the two sets 
`calledFromA` and `calledFromF`:

```rascal-shell
rascal>calledFromA & calledFromF;
set[str]: {"e"}
```
or if your prefer to write all of the above as a one-liner using a [$Rascal:Expressions/Reducer] expression:

```rascal-shell
rascal>(carrier(Calls) | it & (Calls+)[p] | p <- top(Calls));
set[str]: {"e"}
```

The reducer is initialized with  all procedures (`carrier(Calls)`) and iterates over all entry points (`p <- top(Calls)`).
At each iteration the current value of the reducer (`it`) is intersected (`&`) with the procedures called directly or indirectly
from that entry point (`(Calls+)[p]`).

### Benefits 

*  In small examples, the above results can be easily obtained by a visual inspection of the call graph.
Such a visual inspection does _not_ scale very well to large graphs and this makes the above form of analysis particularly suited for studying large systems.

### Pitfalls 

*  We discuss call analysis in a, intentionally, simplistic fashion that does not take into account how the call relation
  is extracted from actual source code.
  The above principles are, however, applicable to real cases as well.



## Word Count {#Common-WordCount}

### Synopsis 
Counting words in strings.






### Examples 

The purpose of WordCount is to count the number of _words_ in a list of lines (strings).
A word is here defined as one or more letters (lowercase or uppercase), digits and the underscore character (`_`).

We split the problem in two parts:

*  Count the words in a single line. We explore three ways to do this in an imperative ([Count in line1](#Common-WordCount-CountInLine1)], [Count in line2](#Common-WordCount-CountInLine2))
  and a functional style ([Count in line3](#Common-WordCount-CountInLine3)).
*  Next we apply the single line counter to all the lines.


`wordCount` is a function with two arguments:
*  A list of lines.
*  A function that returns the number of words in a line.


The main task of `wordCount` is to loop over all lines and to add the word counts per line.


```rascal
include::{LibDir}demo/common/WordCount/WordCount.rsc[tags=module]
```

                
<1> An [enumerator](/Rascal.md#Expressions-Comprehensions-Enumerator) is used to generated all the lines in the list of lines.
<2> The argument function `countInLine` is applied to count the number of words in each line.

Let's now do some experiments using the [Jabberwocky](#Common-WordCount-Jabberwocky) poem by Lewis Carrol as input.


```rascal-shell
rascal>import demo::common::WordCount::WordCount;
ok
rascal>import demo::common::WordCount::CountInLine1;
ok
rascal>import demo::common::WordCount::CountInLine2;
ok
rascal>import demo::common::WordCount::CountInLine3;
ok
rascal>import demo::common::WordCount::Jabberwocky;
ok
rascal>wordCount(Jabberwocky, countInLine1);
int: 216
rascal>wordCount(Jabberwocky, countInLine2);
int: 216
rascal>wordCount(Jabberwocky, countInLine3);
int: 216
```
It is satisfactory that the three ways of counting words all yield the same result.

If you are into one-liners, we can include everything you learned from this example
in the following alternative `wordCount2` function:

```rascal-shell
rascal>int wordCount2(list[str] lines) = (0 | it + (0 | it + 1 | /\w+/ := line) | str line <- lines);
int (list[str]): function(|prompt:///|(0,94,<1,0>,<1,94>))
rascal>wordCount2(Jabberwocky);
int: 216
```
The function body contains two nested [reducers]_broken:Rascal:Expressions-Reducer (ambiguous link)_.
The inner reducer counts the number of words in a line, the outer reducer accumulates all line word counts.


```rascal-shell
```





## CountInLine1 {#Common-WordCount-CountInLine1}

### Synopsis 
Count words in a line.







### Examples 
We count words using a regular expression match in a for loop.
Each time that the pattern `/[a-zA-Z0-9_]+/` matches, the body of the loop is executed
and `count` is incremented.
```rascal
include::{LibDir}demo/common/WordCount/CountInLine1.rsc[tags=module]
```

                
Let's try it:

```rascal-shell
rascal>import demo::common::WordCount::CountInLine1;
ok
rascal>countInLine1("Jabberwocky by Lewis Carroll");
int: 4
```




## CountInLine2 {#Common-WordCount-CountInLine2}

### Synopsis 
Count words in a line.






### Examples 
A slighly more involved manner of using regular matching in a loop.
```rascal
include::{LibDir}demo/common/WordCount/CountInLine2.rsc[tags=module]
```

                
The pattern `/^\W*\w+<rest:.*$>/` can be understood as follows:

*  The `^` makes it anchored, only matches at the begin of the substring `S`.
*  `\W*` matches zero or more non-word characters.
*  `\w+` matches one or more word characters.
*  `<rest:.*$>` matches the remaining part of `S` and assigns the result to the variable `rest`.


Inside the loop `count` is incremented and the new value of `S` becomes
the remainder of the current match. To summarize: each iteration
removes the first word from `S` and counts it.

Here is `countInLine2` in action:

```rascal-shell
rascal>import demo::common::WordCount::CountInLine2;
ok
rascal>countInLine2("Jabberwocky by Lewis Carroll");
int: 4
```




## CountInLine3 {#Common-WordCount-CountInLine3}

### Synopsis 
Count words in a line.






### Examples 

Here is a clever, albeit rather dense, solution that illustrates several Rascal concepts.
```rascal
include::{LibDir}demo/common/WordCount/CountInLine3.rsc[tags=module]
```

                
We use a [reducer]_broken:Rascal:Expressions-Reducer (ambiguous link)_ that is a recipe to reduce the values produced by one or more generators
  to a single value:
  
* `0` is the initial value of the reducer
*  The pattern match `/\w+/ := S` matches all words in `S`.
*  Reduction is done by `it + 1`. In the latter `it` is a keyword that refers to the
   value that has been reduced sofar. Effectively, the matches are reduced to a match count.


Let's try it:

```rascal-shell
rascal>import demo::common::WordCount::CountInLine3;
ok
rascal>countInLine3("Jabberwocky by Lewis Carroll");
int: 4
```




## Jabberwocky {#Common-WordCount-Jabberwocky}

### Synopsis 
Lewis Carroll's well-known poem.






### Examples 
```rascal
include::{LibDir}demo/common/WordCount/Jabberwocky.rsc[tags=module]
```

                



## Word Replacement {#Common-WordReplacement}

### Synopsis 
Replace words in a string.





### Description 
Suppose you are a book editor and want to ensure that all chapter
and section titles are properly capitalized. Here is how to do this. 

### Examples 
```rascal
include::{LibDir}demo/common/WordReplacement.rsc[tags=module]
```

                
<1> We start by introducing a helper function `capitalize` that does the actual capitalization of a single word.
    See [Regular Pattern]_broken:Rascal:Patterns-Regular (ambiguous link)_ for details about regular expression patterns.
    Next we give two versions of a capitalization functions for a sentence:

<2> `capAll1` uses a while loop to find subsequent words and to replace them by a capitalized version.
<3> `capAll2` uses a [Rascal:Visit] to visit all words in the sentence and replace them by a capitalized version.


Here are some examples:


```rascal-shell
rascal>import demo::common::WordReplacement;
ok
rascal>capitalize("rascal");
str: "Rascal"
rascal>capAll1("turn this into a capitalized title")
str: "Turn This Into A Capitalized Title"
rascal>capAll2("turn this into a capitalized title")
str: "Turn This Into A Capitalized Title"
```




## Call Lifting {#Common-CallLifting}

### Synopsis 
Lift procedure calls to component calls.





### Description 
A frequently occurring problem is that we know the call relation of a system but that we want to understand it at the component level rather than at the procedure level. If it is known to which component each procedure belongs, it is possible to lift the call relation to the component level. Actual lifting amounts to translating each call between procedures by a call between components. 

### Examples 
Consider the following figure:


![](/assets/ed6668a3-e73a-430d-b990-7d5998afc586.png)


(a) Shows the calls between procedures;
(b) shows how procedures are part of a system component.
(c) shows how the call relation given in (a) can be lifted to the component level.

The situation can be characterized by:

*  A call relation between procedures
*  A partOf relation between procedures and components


The problem is now to lift the call relation using the information in the partOf relation.
In other words: a call between two procedures will be lifted to
a call between the components to which each procedure belongs.

Here is a solution:
```rascal
include::{LibDir}demo/common/Lift.rsc[tags=module]
```

And we can use it as follows:


```rascal-shell
rascal>import demo::common::Lift;
ok
```
Encode the call relation and partOf relation:

```rascal-shell
rascal>calls = {<"main", "a">, <"main", "b">, <"a", "b">, <"a", "c">, <"a", "d">, <"b", "d">};        
rel[str,str]: {
<"b","d">,
<"a","b">,
<"a","c">,
<"a","d">,
<"main","a">,
<"main","b">
}
rascal>partOf = {<"main", "Appl">, <"a", "Appl">, <"b", "DB">, <"c", "Lib">, <"d", "Lib">};
rel[str,str]: {
<"a","Appl">,
<"b","DB">,
<"c","Lib">,
<"d","Lib">,
<"main","Appl">
}
```
and do the lifting:

```rascal-shell
rascal>lift(calls, partOf);
rel[str,str]: {
<"DB","Lib">,
<"Appl","Lib">,
<"Appl","Appl">,
<"Appl","DB">
}
```
Please verify that this corresponds exactly to (c) in the figure above.

```rascal-shell
```




## Colored Trees {#Common-ColoredTrees}

### Synopsis 
Computations on binary trees.





### Description 
We consider binary trees---trees with exactly two children---that have integers as their leaves. 
Our trees can have red and black nodes and we want to perform the following operations on them:

*  Count the number of red nodes.
*  Compute the sum of all the integers that occur in the leaves.
*  Extend the tree data type with green nodes.
*  Replace all red nodes by green ones.

### Examples 
The definition of ColoredTrees is as follows:
```rascal
include::{LibDir}demo/common/ColoredTrees.rsc[tags=module]
```
       
<1> We define the data type of `ColoredTrees` with constructors `leaf`, `red` and `black`.

<2> `cntRed` counts all red nodes by visiting all nodes and incrementing
the counter `c` for each red one.

<3> `addLeaves` visits all nodes and adds the integers in each leaf node.

<4> `coloredTrees` are extended with a new constructor `green`.

<5> `makeGreen` visits all nodes and turns red nodes in green ones.

We can now explore ColoredTrees:

```rascal-shell
rascal>import demo::common::ColoredTrees;
ok
rascal>rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));
ColoredTree: red(
black(
leaf(1),
red(
leaf(2),
leaf(3))),
black(
leaf(3),
leaf(4)))
```
Count the red nodes in `rb`:

```rascal-shell
rascal>cntRed(rb);
int: 2
```
and compute the sum of all leaves:

```rascal-shell
rascal>addLeaves(rb);
int: 13
```
Finally, we convert all red nodes:

```rascal-shell
rascal>makeGreen(rb);
ColoredTree: green(
black(
leaf(1),
green(
leaf(2),
leaf(3))),
black(
leaf(3),
leaf(4)))
```

### Benefits 
This example illustrates the fully automatic visiting of the elements of a structured data type.
Compare this with the traditional programming style in which a switch statement is used to determine
the constructor and recursion is used to visit substructures. This style becomes particularly cumbersome
for data types with large numbers of constructors such as, for instance, abstract syntax trees for real
programming languages.

### Pitfalls 
The visit statement is based on a new paradigm one has to learn.


## String Template {#Common-StringTemplate}

### Synopsis 
Using string templates to generate code.





### Description 
Many websites and code generators use template-based code generation. They start from a text template that contains embedded variables and code. The template is "executed" by replacing the embedded variables and code by their string value. Languages like PHP and Ruby are popular for this feature. Let's see how we can do this in Rascal. 

Rascal provides string templates that rival what is provided in
http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/ERB.html[Ruby], http://www.php.net/[PHP] or http://www.stringtemplate.org/[ANTLR].
They are fully described in [string values](/Rascal.md#Expressions-Values-String).

### Examples 
The problem we want to solve is as follows: 
given a number of fields (with a name and a type)
how can we generate a Java class with getters and setters for those fields?

Here is a solution:
```rascal
include::{LibDir}demo/common/StringTemplate.rsc[tags=module]
```

                
<1> An auxiliary function `capitalize` is defined to capitalize the first character of a string.

<2> Here is the heavy lifting done: `genClass` is defined that takes as arguments:

*  the `name` of the class, and
*  a map `fields` that associates field names with their type (both string values).


Function `genClass` returns a string that contains several _string interpolations_ delimited by `<` and `>`.
Let's discuss some of them:

*  In each line, only the text following `'` is contributed to the output. The text before (and including) `'` can be used to properly indent
   the string.
*  The output of each interpolated call, like to `genMethod` is auto-indented.
*  `public class <name>`: insert the desired class name in the result.
*  `<for x<-fields){>` ... `<}>`: loops over the fields and contributes the text produced by its body to the result.
*  `private <fields[x]> <x>;`: finds for the current field `x` its type and produces an appropriate private field declaration.
*  `public void set<capitalize(x)>(<fields[x]> <x>)`: method header for the setter for field `x`.

Let's see how this works out on actual data:

```rascal-shell
rascal>import demo::common::StringTemplate;
ok
rascal>import IO;
ok
rascal>fields = (
>>>>>>>     "name" : "String",
>>>>>>>     "age" : "Integer",
>>>>>>>     "address" : "String"
>>>>>>>  );
map[str, str]: ("name":"String","address":"String","age":"Integer")
rascal>println(genClass("Person", fields));
println(genClass("Person", fields));
public class Person {
  
  private String address;
  public void setAddress(String address) {
    this.address = address;
  }
  public String getAddress() {
    return address;
  }
  private Integer age;
  public void setAge(Integer age) {
    this.age = age;
  }
  public Integer getAge() {
    return age;
  }
  private String name;
  public void setName(String name) {
    this.name = name;
  }
  public String getName() {
    return name;
  }
}
ok
```

### Benefits 

*  String templates are ideal to generate arbitrary output. In particular, no grammar is needed to describe this output.
*  Auto-indent helps to be able to compose templates from reusable parts.

### Pitfalls 

*  Since no grammar is used to control output, errors in generated code can only be detected by a downstream processor such as a compiler for the generated code.

*  In more complex cases, it can be better to introduce an abstract datatype to represent the desired code and to use string templates to
produce the actual textual representation of that code.


## Ad Hoc Data Exploration {#Common-AdHocDataExploration}

### Synopsis 
Using Rascal to explore an interesting data space.





### Description 
The problem we will look at comes from mathematics, and has a precise analytical solution, but
let's use Rascal to explore the state space, and see how it can help us to build intuition.

As you know, Rascal supports arbitrarily large numbers cleanly and simply, unlike more traditional 
languages like C or Java.  For example, if you want to compute 1000!, then it's a simple matter of
calling `fact(1000)` at the command line.  Let's use this definition of factorial:

```rascal
public int fact (int n) {
    if (n <= 1) {
	    return 1;
    } else {
	    return n * fact (n-1);
    }
}
```

If you compute `fact(1000)` at the Rascal command line, you get a large number, on the order of 4.02 x 10^2567^. This is much, much bigger than, say a google, which is a mere 10<^>100^.  (If Rascal runs out stack space, try computing 100!, then 200!, then ... then 1000!; the run-time will allocate more stack space incrementally and automatically if you sneak up to where you want to go).

```rascal
rascal> fact(1000);
int: 402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

Now copy the numerical result above and paste it into an edit window to have a good look at it.  Notice anything interesting?  The last 249 digits are all zeros.  How did this happen and what does it mean?

To be honest, when I did this calculation for the first time, I thought I'd found a bug.  So I looked at the values of N! for N in the range 900 to 1000 and discovered that the zeros accumulate on the end of N! as N gets bigger.  Let's think about it for a bit:  N! is a cumulative product, so once a zero has appeared on the end there is no way to get rid of it by multiplying by a positive integer.

How do the zeros appear?  Well, this isn't to hard to figure out.  Obviously, each time you reach a multiple of 10, you will add (at least) one more zero to the cumulative product.  But what about multiples of 5?  Well, you would add one more zero if you can match the 5 to a 2 within the factors, and there are lots of lonely 2s in that list.  So, to summarize, each time N is a multiple of 5, you add at least one zero onto the cumulative product N!.

So here's the question we're going to solve:  For an arbitrary N, can you predict exactly how many trailing zeros there will be in N!?  

Again, this can be solved analytically (and if you go looking on the web, you will discover that this is an old chestnut of a math problem that's sometimes used in job interviews to test analytical ability), but what I want to do here is to show how we can use Rascal to play around with the problem space a bit to help us build up our intuition.  This is very much like what we do in empirical software engineering, when we have lots of data to analyze, and we're trying to look for patterns that might explain behaviours, such as why some functions are more likely to be associated with bugs than others.  In that kind of situation, we typically go through two stages:  first, we wade through the data, exploring relationships, looking for unusual lumps or recognizable patters; second, we build theories of how the world works, and test them out using the data.  In both stages, we not only look at the data, we play with it.  We build little tools to help answer our questions, see where our hunches lead us.  We use this "play" to improve our understanding of the problem space, and build intuition about how it works as testable theories.  In empirical software engineering, as in most other sciences, we usually don't get concrete proof of a theory; rather, we gather evidence towards ultimately accepting or rejecting the theories (tho often, we may choose to use this evidence to refine the theories and try again).

In this case, however, there is a precise analytical solution, a proof, a "ground truth".  But that doesn't mean that we can't use the empirical approach to help build our intuition about the problem space, and ultimately devise a theory about how to calculate the number of trailing zeros in N!.  Solving analytical problems is about having enough intuition to see possible solutions.  And using this empirical approach is one way to build intuition.

So let's define a few helper functions and see where that leads us:
```rascal
public int countZeros (int n) {
    if (n < 10) {
	    return 0;
    } else if (n % 10 == 0) {
        return 1 + countZeros (n / 10);
    } else {
	    return countZeros (n / 10);
    }   
}
rascal> int i = fact(1000);
int: 402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
rascal> countZeros(i);
int: 472
```

This was my first try at the solution (really!), and there's a problem: 1000! has exactly 249 trailing zeros, not 472.  

What did I do wrong?  Oh, right, _trailing_ zeros, and the above function counts _all_ of the zeros.  Let's try again:

```rascal
public int countTrailingZeros (int n) {
    if (n < 10) {
	    return 0;
    } else if (n % 10 == 0) {
        return 1 + countTrailingZeros (n / 10);
    } else {
	    return 0 ;
    }   
}

rascal> countTrailingZeros(i);
int: 249
```

OK, so we're making progress.  Let's define another function to help us explore the data space:

```rascal
public void printLastTwenty (int n){
    for(int i <- [n-19..n+1]) {
        println ("<i>! has <countTrailingZeros(fact(i))> trailing zeros.");
    }
}

rascal>printLastTwenty(1000);
981! has 243 trailing zeros.
982! has 243 trailing zeros.
983! has 243 trailing zeros.
984! has 243 trailing zeros.
985! has 244 trailing zeros.
986! has 244 trailing zeros.
987! has 244 trailing zeros.
988! has 244 trailing zeros.
989! has 244 trailing zeros.
990! has 245 trailing zeros.
991! has 245 trailing zeros.
992! has 245 trailing zeros.
993! has 245 trailing zeros.
994! has 245 trailing zeros.
995! has 246 trailing zeros.
996! has 246 trailing zeros.
997! has 246 trailing zeros.
998! has 246 trailing zeros.
999! has 246 trailing zeros.
1000! has 249 trailing zeros.
ok
```
So the pattern I see arising (confirmed by more playing that I won't show you) is that you add a zero every time N is divisible by 5.  But sometimes you add more than one zero: 1000! adds three zeros.  

We defined one function above to help us look at the data more compactly; now let's create another function to look for lumps in the data:
```rascal
// Printout all i in [0..n] where i! has more trailing zeros than (i-1)!
public void findLumps (int n) {
    int iMinusOneFactZeros = 0;
    for (int i <- [1..n+1]) {
        int iFactZeros = countTrailingZeros(fact(i));
        int diff = iFactZeros - iMinusOneFactZeros ;
        if (diff >= 1) {
            println ("<diff> more zeros at <i>!");
        }
        iMinusOneFactZeros = iFactZeros;
    }
}

rascal>findLumps(1000);
1 more zeros at 5!
1 more zeros at 10!
1 more zeros at 15!
1 more zeros at 20!
2 more zeros at 25!
1 more zeros at 30!
1 more zeros at 35!
1 more zeros at 40!
1 more zeros at 45!
2 more zeros at 50!
1 more zeros at 55!
1 more zeros at 60!
1 more zeros at 65!
1 more zeros at 70!
2 more zeros at 75!
1 more zeros at 80!
1 more zeros at 85!
1 more zeros at 90!
1 more zeros at 95!
2 more zeros at 100!
1 more zeros at 105!
1 more zeros at 110!
1 more zeros at 115!
1 more zeros at 120!
3 more zeros at 125!
1 more zeros at 130!
...
1 more zeros at 245!
3 more zeros at 250!
1 more zeros at 255!
1 more zeros at 495!
3 more zeros at 500!
1 more zeros at 505!
...
1 more zeros at 620!
4 more zeros at 625!
1 more zeros at 630!
...
1 more zeros at 985!
1 more zeros at 990!
1 more zeros at 995!
3 more zeros at 1000!
ok
```

So probably we're noticing some patterns here already, and maybe forming some intuition.  But let's first revise our lump-finding function to produce even more concise output:

```rascal
// We can parameterize the threshold to look for jumps of 2, 3, or 4 zeros
public void findLumps2 (int n, int tao) {
    int iMinusOneFactZeros = 0;
    for (int i <- [1..n+1]) {
        int iFactZeros = countTrailingZeros(fact(i));
        int diff = iFactZeros - iMinusOneFactZeros ;
        if (diff >= tao) {
            println ("<diff> more zeros at <i>!");
        }
        iMinusOneFactZeros = iFactZeros;
    }
}

rascal>findLumps2(1000,2);
2 more zeros at 25!
2 more zeros at 50!
2 more zeros at 75!
2 more zeros at 100!
3 more zeros at 125!
2 more zeros at 150!
2 more zeros at 175!
2 more zeros at 200!
2 more zeros at 225!
3 more zeros at 250!
2 more zeros at 275!
...
2 more zeros at 950!
2 more zeros at 975!
3 more zeros at 1000!
ok

rascal>findLumps2(1000,3);
3 more zeros at 125!
3 more zeros at 250!
3 more zeros at 375!
3 more zeros at 500!
4 more zeros at 625!
3 more zeros at 750!
3 more zeros at 875!
3 more zeros at 1000!
ok

rascal>findLumps2(1000,4);
4 more zeros at 625!
ok
```

Notice anything yet?  Here are some fun math facts to consider:

*  5^0^ = 1
*  5^1^ = 5
*  5 ^2^ = 25
*  5^3^ = 125
*  5^4^ = 625
*  5^5^ = 3125

So here's the solution:

Let N be a positive integer.  

Let k = floor (log N)

Start a counter at zero, call it nz

We want to examine i <- [1..N+1]

*  If i  is not divisible by 5, ignore it
*  If  i  is divisible by 5, add 1 to nz
*  If  i  is also divisible by 25, add 1 more
*  ...
*  If  i is also divisible by 2k, add 1 more

We can write this in Rascal as:
```rascal
public int predictZeros (int N) {
    int k = floorLogBase(N, 5);  // I wrote this
    int nz = 0;
    for (int i <- [1..N+1] ) {
	    int p5 = 1;
        for (int j <- [1..k+1]) {
            p5 *= 5;
    	    if (i % p5 == 0) {
		        nz += 1;
	        } else {
                break;
	        }
	    }
    }
    return nz; 
}
```

Now a little hand validation might convince you that this should work, but let's write a little verifier function to be sure:

```rascal
public void verifyTheory (int N) {
    int checkInterval = 100; // for printing
    bool failed = false;
    for (int i <- [1..N+1]) {
        ifact=fact(i);
    	int p = predictZeros(i);
    	int c = countTrailingZeros(ifact);
    	if (p != c) {
	        failed = true;
	        println ("Found a counter example at i=<i>");
	        break;
    	} else {
	        if (i % checkInterval == 0) {
		        println ("<i>! has <p> trailing zeros");
	        }
	    }
    }
    if (!failed) {
	    println ("The theory works for i: 1..<N>");
    }
}

rascal>verifyTheory(10);
The theory works for i: 1..10
ok

rascal>verifyTheory(100);
100! has 24 trailing zeros
The theory works for i: 1..100
ok

rascal>verifyTheory(1000);
100! has 24 trailing zeros
200! has 49 trailing zeros
300! has 74 trailing zeros
400! has 99 trailing zeros
500! has 124 trailing zeros
600! has 148 trailing zeros
Found a counter example at i=625
    predicted zeros = 155
    observed zeros  = 156
ok
```

Yikes, what do we do?  Well, first let's look under the hood at the engine.  The function `predictZeros` _is_ actually correct, assuming that the functions is calls are correct.  So let's look at the auxiliary functions I wrote (but haven't shown you yet):

```rascal
// Log for an arbitrary base
public real logB(real a, real base) {
    return log(a) / log(base);
}

public real floor (real a) {
    return toReal(round (a - 0.5));
}

public int floorLogBase (int a, int b) {
    return toInt(floor(logB(toReal(a), toReal(b))));
}

rascal>floorLogBase(625,5);
int: 3
rascal>logB(625.0,5.0);
real: 3.9999999999999998757330130880776320985295476764801684...
```

Oh right, real numbers are prone to round off error.  What should we do?

Well, here's a bad solution (that "works"):

```rascal
public real floor (real a) {
    return toReal(round (a - 0.5 + 0.00001));
}
```
But how can I be sure that that's enought decimal places?  What if someone likes my `floor` function and sticks it into the Rascal library, where it is subsequently used by the Eurpoean Space Agency for its next generation of flight control software?

Sometimes, the answer is to do a lot of homework.  Lucky for us, here there is a fairly efficient exact solution using repeated integer division:
```rascal
// Also change predictZeros to call this version
public int floorLogBase2 (int a, int b) {
    int remaining = a;
    int ans = 0;
    while (remaining >= b) {
	    ans += 1;
	    remaining /= b;
    }
    return ans;		
}

rascal>verifyTheory(1000);
100! has 24 trailing zeros
200! has 49 trailing zeros
300! has 74 trailing zeros
400! has 99 trailing zeros
500! has 124 trailing zeros
600! has 148 trailing zeros
700! has 174 trailing zeros
800! has 199 trailing zeros
900! has 224 trailing zeros
1000! has 249 trailing zeros
The theory works for i: 1..1000
ok
```

And we're done.  But what did we learn here?  Here's what I think:

*  Explore the terrain, take notes, build intuition, develop theories, test them.
**  Refine and repeat
**  Double check!

*  Build infrastructure with natural "break points"
**  Understandable is better than fast, esp. in the beginning
**  The correct way is better than the easy way
***  The correct way may be pretty easy too

*  Document and later challenge your assumptions 
**  Are you measuring what you think you are measuring?  How do you know?







## Count Constructors {#Common-CountConstructors}

### Synopsis 
Generic function that can count constructors in a value of any algebraic data type.





### Description 
In [Colored trees](#Common-ColoredTrees), we have seen a function that can count the number of red nodes in a `ColoredTree`.
Is it possible to define a function that can count constructors in a value of any algerbaic data type?

We exploit the subtype relation (see [Static Typing]_Rascal:Concepts-StaticTyping (broken link)_) 
between [algebraic data types]_Rascal:Declrations-AlgebraicDataType (broken link)_s 
and the type [node](/Rascal.md#Expressions-Values-Node) to achieve this.

In real applications this becomes relevant when counting, for instance, statement types in programs.

### Examples 

```rascal
include::{LibDir}demo/common/CountConstructors.rsc[tags=module]
```

                
Two data types are introduced `ColoredTree` and `Hand` together
with an example value of each (`CT`, respectively, `H`).

<1> The function `count` is defined.

<2> Introduces an empty map to maintain the frequencies.
<3> Defines a visit of argument `N`; it traverses the complete value of `N`.
<4> Defines the case that we encounter a node and we update its frequency count.
  First the name of the constructor is retrieved (using [getName]_Libraries:Node-getName (broken link)_) and then the
  frequency is updated. The [isDefined](/Rascal.md#Statements-Assignment-IsDefined) operator is used to provide a default value of 0 when
  the name was not yet in the map.
<5> The map `freq` is returned as result.
<6> Defines a variant `countRelevant`; it gets is an extra argument of relevant constructors
names that is used to filter the map that is returned by `count` using [domainR]_Libraries:Map-domainR (broken link)_.


```rascal-shell
rascal>import demo::common::CountConstructors;
ok
rascal>count(CT);
map[str, int]: ("red":2,"leaf":5,"black":2)
rascal>count(H);
map[str, int]: ("six":1,"ace":1,"two":1,"hearts":2,"spades":1,"hand":1,"diamonds":1,"jack":1)
rascal>countRelevant(H, {"hearts", "spades"});
map[str, int]: ("hearts":2,"spades":1)
```




