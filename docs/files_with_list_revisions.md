# Multi-level list revisions

Multi-level lists in Rascal's documentation are repeatedly defined by prepending 
a given entry with a number of star characters (`*`) equal to the level of the list.

According to the Markdown specification, a multi-level list is defined as an indented
list, still using just one character to denote a list item (e.g. a single `*`).

Because of the multiple stars where lists are supposed to appear nested, the content 
is rendered as one solid text paragraph which it makes it slighlty more difficult to 
read.

The following list was generated by running:

```
  > egrep -R -n ' \*\* ' ./ 
```

from within `docs/`.

This enumerates all files that contain the pattern that the author(s) have used to 
denote multi-level lists of at least two levels. There is at least one three level 
list that has been defined using this pattern (i.e. `docs/Rascal/Expressions/Visit/index.md`
lines 773 and 832) which would also need revision.

Hope this helps.
Athanasios Anastasiou


## Specific multi-level lists to be revised

```

./Rascal/Errors/RunTimeErrors/RuntimeExceptions/IndexOutOfBounds/index.md:28:  ** Use the [index](../../../../../Library/List.md#List-index) to produce all legal indices of a list. 
./Rascal/Errors/RunTimeErrors/RuntimeExceptions/IndexOutOfBounds/index.md:30:  ** Use a [list slice](../../../../../Rascal/Expressions/Values/List/Slice/index.md) to automate part of the index computation.
./Rascal/Errors/CompileTimeErrors/SyntaxError/index.md:25:   ** The module parses. The top part is correct and the syntax error is in the bottom part. 
./Rascal/Errors/CompileTimeErrors/SyntaxError/index.md:27:   ** The module does not parse. The syntax error is in the top part.
./Rascal/Statements/Fail/index.md:39:   ** In the case of switch or visit this means that the next case will be tried.
./Rascal/Statements/Fail/index.md:40:   ** For while, do and for, this implies that any bindings caused by the pattern are undone and that the next 
./Rascal/Statements/Fail/index.md:42:   ** For a function call it means that the next function declaration (or the default one) is tried.
./Rascal/Statements/Assignment/Slice/index.md:44:  **  If the number of elements in the slice is larger: the elements of _Exp₄_ are used in a circular manner.
./Rascal/Statements/Assignment/Slice/index.md:45:  **  If the number of elements in the slice is smaller: the remaining elements of _Exp₄_ is inserted after the last index in the slice.
./Rascal/Declarations/SyntaxDefinition/Disambiguation/index.md:15:   **  [Priorities](../../../../Rascal/Declarations/SyntaxDefinition/Disambiguation/Priority/index.md)s, which can be used to define the relative priority in expression languages
./Rascal/Declarations/SyntaxDefinition/Disambiguation/index.md:16:   **  [./Associativity](../../../../Rascal/Declarations/SyntaxDefinition/Disambiguation/Associativity/index.md)s, which can be used to define relative associativity between operators of 
./Rascal/Declarations/SyntaxDefinition/Disambiguation/index.md:18:   **  [Follow](../../../../Rascal/Declarations/SyntaxDefinition/Disambiguation/Follow/index.md) constraints, which can be used to implement longest match using lookahead
./Rascal/Declarations/SyntaxDefinition/Disambiguation/index.md:19:   **  [Precede](../../../../Rascal/Declarations/SyntaxDefinition/Disambiguation/Precede/index.md) constraints, which can be used to implement first match using look behind
./Rascal/Declarations/SyntaxDefinition/Disambiguation/index.md:20:   **  [Reserve](../../../../Rascal/Declarations/SyntaxDefinition/Disambiguation/Reserve/index.md) constraintss, which allow you to remove a finite sets of strings from a [Syntax Definition](../../../../Rascal/Declarations/SyntaxDefinition/index.md)
./Rascal/Declarations/Function/index.md:122:   **  `java` declares that the body of the function is implemented in Java. The function should have a
./Rascal/Declarations/Function/index.md:124:   **  `test` declares that this is a test function. A test function is a boolean function (currently) without arguments. 
./Rascal/Declarations/Function/index.md:127:   **  `default` declares an alternative for an overloaded function that will only be tried after 
./Rascal/Expressions/Visit/index.md:85:   ** Execution of an Insert statement of the form `insert Exp₂`.
./Rascal/Expressions/Visit/index.md:94:   ** Execution of a [Fail](../../../Rascal/Statements/Fail/index.md) statement: the next case is tried.
./Rascal/Expressions/Visit/index.md:96:   ** Execution of a [Return](../../../Rascal/Statements/Return/index.md) statement that returns a value from the enclosing function.
./Recipes/Languages/Lisra/Parse/index.md:42:   **  First the text is parsed using `parse(#LispExp, txt)`. The result is parse tree.
./Recipes/Languages/Lisra/Parse/index.md:43:   **  Next, the auxiliary function `build` is used to transform the parse tree to an `Lval`.
./Recipes/Languages/Func/index.md:16:  **  an integer constant.
./Recipes/Languages/Func/index.md:17:  **  a variable.
./Recipes/Languages/Func/index.md:18:  **  arithmetic operators `+`, `-`, `*` and `/`.
./Recipes/Languages/Func/index.md:19:  **  comparison operators `<`, `\<=`, `>` and `>=`.
./Recipes/Languages/Func/index.md:20:  **  a call of a function.
./Recipes/Languages/Func/index.md:21:  **  an `if` expression.
./Recipes/Languages/Func/index.md:22:  **  a sequence of expressions (`;`).
./Recipes/Languages/Func/index.md:23:  **  an assignment (`:=`).
./Recipes/Languages/Func/index.md:24:  **  a `let` expression to introduce new bindings for local variables.
./Recipes/Languages/Func/index.md:25:  **  an address of a variables (denoted by `&`).
./Recipes/Languages/Func/index.md:26:  **  derefence of a variable (denoted by `*`).
./WhyRascal/SolutionStrategies/Extraction/index.md:24:   **  Checking that all sources are available (and can be compiled by the host system on which they are usually compiled and executed). Due to missing or unreliable configuration management on the original system this may be a labour-intensive step that requires many iterations.
./WhyRascal/SolutionStrategies/Extraction/index.md:26:   **  Determining in which languages the sources are written. In larger systems it is common that three or more different languages are being used.
./WhyRascal/SolutionStrategies/Synthesis/index.md:18:  **  Generated source code.
./WhyRascal/SolutionStrategies/Synthesis/index.md:20:  **  Generated abstract representations, like finite automata or other formals models that capture properties of the SUI.
./WhyRascal/SolutionStrategies/Synthesis/index.md:22:  **  Generated data for visualizations that will be used by visualization tools. 
./WhyRascal/SolutionStrategies/Synthesis/index.md:26:  **  Print strings with embedded variables.
./WhyRascal/SolutionStrategies/Synthesis/index.md:28:  **  Convert abstract syntax trees to strings (perhaps using forms of pretty printing).
./WhyRascal/SolutionStrategies/Synthesis/index.md:30:  **  Use a grammar of the target source language, also for code generation. 
./WhyRascal/SolutionStrategies/Analysis/index.md:18:  **  Reordering extracted facts to make them more suitable for the synthesis phase.
./WhyRascal/SolutionStrategies/Analysis/index.md:20:  **  Enriching extracted facts. Examples are computing transitive closures of extracted facts 
./WhyRascal/SolutionStrategies/Analysis/index.md:24:  **  Combining enriched, extracted, facts to create new facts.
./Tutor/Authoring/index.md:27:  ** A complete concept can be easily moved or renamed as a single unit.
./Tutor/Authoring/index.md:28:  ** Name clashes between included files per concept are avoided.
./Tutor/Markup/QuestionMarkup/TypeDescriptor/index.md:46:   **  given an integer that defines the maximal depth of the type.
./Tutor/Markup/QuestionMarkup/TypeDescriptor/index.md:47:   **  given an explicit list of types to choose from.
Binary file ./assets/Rascalopedia/List/hot100.png matches
./Library/IO.md:879:   **  Are the first 32 bytes valid UTF-8? Then use UTF-8.
./Library/IO.md:880:   **  Are the first 32 bytes valid UTF-32? Then use UTF-32.i

```

